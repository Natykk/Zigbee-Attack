<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>scripts.beaconSpam API documentation</title>
<meta name="description" content="Ce module implémente un spammer de beacons WiFi avec des informations sur la vitesse d&#39;envoi des paquets.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scripts.beaconSpam</code></h1>
</header>
<section id="section-intro">
<p>Ce module implémente un spammer de beacons WiFi avec des informations sur la vitesse d'envoi des paquets.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scripts.beaconSpam.WifiSpammer"><code class="flex name class">
<span>class <span class="ident">WifiSpammer</span></span>
<span>(</span><span>interface: str,<br>channel: int = 1,<br>ssid: str = 'TestSSID',<br>max_queue_size: int = 1000)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WifiSpammer:
    &#34;&#34;&#34;
    @class WifiSpammer
    @brief Classe pour spammer le réseau WiFi avec des paquets Beacon.
    @details Cette classe gère l&#39;envoi de paquets Beacon WiFi de manière multithreadée. Elle permet de configurer
             le canal, de créer les paquets Beacon, de les envoyer et de surveiller le progrès de l&#39;envoi.
    &#34;&#34;&#34;

    def __init__(self, interface: str, channel: int = 1, ssid: str = &#34;TestSSID&#34;, max_queue_size: int = 1000):
        &#34;&#34;&#34;
        @brief Constructeur de la classe WifiSpammer.
        
        @param interface: Interface réseau à utiliser pour l&#39;envoi des paquets.
        @param channel: Canal WiFi sur lequel les paquets Beacon seront envoyés (par défaut : 1).
        @param ssid: SSID à diffuser dans les paquets Beacon (par défaut : &#34;TestSSID&#34;).
        @param max_queue_size: Taille maximale de la file d&#39;attente pour les paquets (par défaut : 1000).
        &#34;&#34;&#34;
        self.interface = interface
        self.channel = channel
        self.ssid = ssid
        self.packet_queue = Queue(maxsize=max_queue_size)
        self.running = False
        self.sent_count = 0
        self.start_time = 0

    def set_channel(self):
        &#34;&#34;&#34;
        @brief Configure l&#39;interface WiFi sur le canal spécifié.
        
        @exception Exception: Si une erreur survient lors de la configuration du canal.
        &#34;&#34;&#34;
        try:
            # os.system(f&#34;iwconfig {self.interface} channel {self.channel}&#34;)
            print(f&#34;Canal configuré sur {self.channel}&#34;)
        except Exception as e:
            print(f&#34;Erreur lors de la configuration du canal : {e}&#34;)

    def create_beacon_packet(self) -&gt; RadioTap:
        &#34;&#34;&#34;
        @brief Crée un paquet Beacon WiFi.
        
        @return: Un paquet de type RadioTap, contenant un paquet Beacon WiFi configuré avec le SSID et le canal.
        &#34;&#34;&#34;
        return (RadioTap()
                / Dot11(type=0, subtype=8,
                        addr1=&#39;ff:ff:ff:ff:ff:ff&#39;,
                        addr2=&#39;00:11:22:33:44:55&#39;,
                        addr3=&#39;ff:ff:ff:ff:ff:ff&#39;)
                / Dot11Beacon(cap=&#39;ESS&#39;)
                / Dot11Elt(ID=&#39;SSID&#39;, info=self.ssid)
                / Dot11Elt(ID=&#39;DSset&#39;, info=chr(self.channel)))

    def packet_sender(self):
        &#34;&#34;&#34;
        @brief Fonction dédiée à la gestion de l&#39;envoi des paquets Beacon.
        
        @details Cette fonction est exécutée dans un thread pour envoyer en continu les paquets Beacon. Les paquets
                 sont envoyés par lots de 10 pour optimiser les performances.
        &#34;&#34;&#34;
        beacon_packet = self.create_beacon_packet()

        while self.running:
            try:
                # Envoi par lots de paquets
                sendp(beacon_packet, iface=self.interface, verbose=False, count=10)
                with threading.Lock():
                    self.sent_count += 10
            except Exception as e:
                print(f&#34;Erreur lors de l&#39;envoi du paquet : {e}&#34;)
                time.sleep(0.1)  # Temporisation en cas d&#39;erreur

    def monitor_progress(self):
        &#34;&#34;&#34;
        @brief Surveille et rapporte la progression de l&#39;envoi des paquets.
        
        @details Cette fonction est exécutée dans un thread pour afficher en temps réel le nombre de paquets envoyés
                 ainsi que le taux d&#39;envoi en paquets par seconde.
        &#34;&#34;&#34;
        while self.running:
            elapsed_time = time.time() - self.start_time
            rate = self.sent_count / elapsed_time if elapsed_time &gt; 0 else 0
            print(f&#34;Envoyé {self.sent_count} paquets sur le canal {self.channel} | Taux : {rate:.2f} paquets/sec&#34;)
            time.sleep(1)

    def start_scan(self, num_sender_threads: int = 4):
        &#34;&#34;&#34;
        @brief Démarre le processus d&#39;envoi des paquets Beacon avec plusieurs threads.
        
        @param num_sender_threads: Nombre de threads d&#39;envoi (par défaut : 4). Chaque thread envoie des paquets Beacon.
        
        @details Cette méthode configure d&#39;abord le canal WiFi, puis lance plusieurs threads pour envoyer les paquets
                 Beacon. Un thread séparé est utilisé pour surveiller le progrès de l&#39;envoi.
        &#34;&#34;&#34;
        self.set_channel()

        self.running = True
        self.start_time = time.time()

        # Lancement des threads d&#39;envoi
        sender_threads = []
        for _ in range(num_sender_threads):
            thread = threading.Thread(target=self.packet_sender)
            thread.daemon = True
            thread.start()
            sender_threads.append(thread)

        # Démarrage du thread de surveillance
        monitor_thread = threading.Thread(target=self.monitor_progress)
        monitor_thread.daemon = True
        monitor_thread.start()

        try:
            # Maintient le thread principal actif
            while True:
                time.sleep(0.1)
        except KeyboardInterrupt:
            print(&#34;\nArrêt du scan...&#34;)
            self.running = False

            # Attend que tous les threads se terminent
            for thread in sender_threads:
                thread.join()
            monitor_thread.join()</code></pre>
</details>
<div class="desc"><p>@class WifiSpammer
@brief Classe pour spammer le réseau WiFi avec des paquets Beacon.
@details Cette classe gère l'envoi de paquets Beacon WiFi de manière multithreadée. Elle permet de configurer
le canal, de créer les paquets Beacon, de les envoyer et de surveiller le progrès de l'envoi.</p>
<p>@brief Constructeur de la classe WifiSpammer.</p>
<p>@param interface: Interface réseau à utiliser pour l'envoi des paquets.
@param channel: Canal WiFi sur lequel les paquets Beacon seront envoyés (par défaut : 1).
@param ssid: SSID à diffuser dans les paquets Beacon (par défaut : "TestSSID").
@param max_queue_size: Taille maximale de la file d'attente pour les paquets (par défaut : 1000).</p></div>
<h3>Methods</h3>
<dl>
<dt id="scripts.beaconSpam.WifiSpammer.create_beacon_packet"><code class="name flex">
<span>def <span class="ident">create_beacon_packet</span></span>(<span>self) ‑> scapy.layers.dot11.RadioTap</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_beacon_packet(self) -&gt; RadioTap:
    &#34;&#34;&#34;
    @brief Crée un paquet Beacon WiFi.
    
    @return: Un paquet de type RadioTap, contenant un paquet Beacon WiFi configuré avec le SSID et le canal.
    &#34;&#34;&#34;
    return (RadioTap()
            / Dot11(type=0, subtype=8,
                    addr1=&#39;ff:ff:ff:ff:ff:ff&#39;,
                    addr2=&#39;00:11:22:33:44:55&#39;,
                    addr3=&#39;ff:ff:ff:ff:ff:ff&#39;)
            / Dot11Beacon(cap=&#39;ESS&#39;)
            / Dot11Elt(ID=&#39;SSID&#39;, info=self.ssid)
            / Dot11Elt(ID=&#39;DSset&#39;, info=chr(self.channel)))</code></pre>
</details>
<div class="desc"><p>@brief Crée un paquet Beacon WiFi.</p>
<p>@return: Un paquet de type RadioTap, contenant un paquet Beacon WiFi configuré avec le SSID et le canal.</p></div>
</dd>
<dt id="scripts.beaconSpam.WifiSpammer.monitor_progress"><code class="name flex">
<span>def <span class="ident">monitor_progress</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def monitor_progress(self):
    &#34;&#34;&#34;
    @brief Surveille et rapporte la progression de l&#39;envoi des paquets.
    
    @details Cette fonction est exécutée dans un thread pour afficher en temps réel le nombre de paquets envoyés
             ainsi que le taux d&#39;envoi en paquets par seconde.
    &#34;&#34;&#34;
    while self.running:
        elapsed_time = time.time() - self.start_time
        rate = self.sent_count / elapsed_time if elapsed_time &gt; 0 else 0
        print(f&#34;Envoyé {self.sent_count} paquets sur le canal {self.channel} | Taux : {rate:.2f} paquets/sec&#34;)
        time.sleep(1)</code></pre>
</details>
<div class="desc"><p>@brief Surveille et rapporte la progression de l'envoi des paquets.</p>
<p>@details Cette fonction est exécutée dans un thread pour afficher en temps réel le nombre de paquets envoyés
ainsi que le taux d'envoi en paquets par seconde.</p></div>
</dd>
<dt id="scripts.beaconSpam.WifiSpammer.packet_sender"><code class="name flex">
<span>def <span class="ident">packet_sender</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def packet_sender(self):
    &#34;&#34;&#34;
    @brief Fonction dédiée à la gestion de l&#39;envoi des paquets Beacon.
    
    @details Cette fonction est exécutée dans un thread pour envoyer en continu les paquets Beacon. Les paquets
             sont envoyés par lots de 10 pour optimiser les performances.
    &#34;&#34;&#34;
    beacon_packet = self.create_beacon_packet()

    while self.running:
        try:
            # Envoi par lots de paquets
            sendp(beacon_packet, iface=self.interface, verbose=False, count=10)
            with threading.Lock():
                self.sent_count += 10
        except Exception as e:
            print(f&#34;Erreur lors de l&#39;envoi du paquet : {e}&#34;)
            time.sleep(0.1)  # Temporisation en cas d&#39;erreur</code></pre>
</details>
<div class="desc"><p>@brief Fonction dédiée à la gestion de l'envoi des paquets Beacon.</p>
<p>@details Cette fonction est exécutée dans un thread pour envoyer en continu les paquets Beacon. Les paquets
sont envoyés par lots de 10 pour optimiser les performances.</p></div>
</dd>
<dt id="scripts.beaconSpam.WifiSpammer.set_channel"><code class="name flex">
<span>def <span class="ident">set_channel</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_channel(self):
    &#34;&#34;&#34;
    @brief Configure l&#39;interface WiFi sur le canal spécifié.
    
    @exception Exception: Si une erreur survient lors de la configuration du canal.
    &#34;&#34;&#34;
    try:
        # os.system(f&#34;iwconfig {self.interface} channel {self.channel}&#34;)
        print(f&#34;Canal configuré sur {self.channel}&#34;)
    except Exception as e:
        print(f&#34;Erreur lors de la configuration du canal : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>@brief Configure l'interface WiFi sur le canal spécifié.</p>
<p>@exception Exception: Si une erreur survient lors de la configuration du canal.</p></div>
</dd>
<dt id="scripts.beaconSpam.WifiSpammer.start_scan"><code class="name flex">
<span>def <span class="ident">start_scan</span></span>(<span>self, num_sender_threads: int = 4)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_scan(self, num_sender_threads: int = 4):
    &#34;&#34;&#34;
    @brief Démarre le processus d&#39;envoi des paquets Beacon avec plusieurs threads.
    
    @param num_sender_threads: Nombre de threads d&#39;envoi (par défaut : 4). Chaque thread envoie des paquets Beacon.
    
    @details Cette méthode configure d&#39;abord le canal WiFi, puis lance plusieurs threads pour envoyer les paquets
             Beacon. Un thread séparé est utilisé pour surveiller le progrès de l&#39;envoi.
    &#34;&#34;&#34;
    self.set_channel()

    self.running = True
    self.start_time = time.time()

    # Lancement des threads d&#39;envoi
    sender_threads = []
    for _ in range(num_sender_threads):
        thread = threading.Thread(target=self.packet_sender)
        thread.daemon = True
        thread.start()
        sender_threads.append(thread)

    # Démarrage du thread de surveillance
    monitor_thread = threading.Thread(target=self.monitor_progress)
    monitor_thread.daemon = True
    monitor_thread.start()

    try:
        # Maintient le thread principal actif
        while True:
            time.sleep(0.1)
    except KeyboardInterrupt:
        print(&#34;\nArrêt du scan...&#34;)
        self.running = False

        # Attend que tous les threads se terminent
        for thread in sender_threads:
            thread.join()
        monitor_thread.join()</code></pre>
</details>
<div class="desc"><p>@brief Démarre le processus d'envoi des paquets Beacon avec plusieurs threads.</p>
<p>@param num_sender_threads: Nombre de threads d'envoi (par défaut : 4). Chaque thread envoie des paquets Beacon.</p>
<p>@details Cette méthode configure d'abord le canal WiFi, puis lance plusieurs threads pour envoyer les paquets
Beacon. Un thread séparé est utilisé pour surveiller le progrès de l'envoi.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scripts" href="index.html">scripts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scripts.beaconSpam.WifiSpammer" href="#scripts.beaconSpam.WifiSpammer">WifiSpammer</a></code></h4>
<ul class="">
<li><code><a title="scripts.beaconSpam.WifiSpammer.create_beacon_packet" href="#scripts.beaconSpam.WifiSpammer.create_beacon_packet">create_beacon_packet</a></code></li>
<li><code><a title="scripts.beaconSpam.WifiSpammer.monitor_progress" href="#scripts.beaconSpam.WifiSpammer.monitor_progress">monitor_progress</a></code></li>
<li><code><a title="scripts.beaconSpam.WifiSpammer.packet_sender" href="#scripts.beaconSpam.WifiSpammer.packet_sender">packet_sender</a></code></li>
<li><code><a title="scripts.beaconSpam.WifiSpammer.set_channel" href="#scripts.beaconSpam.WifiSpammer.set_channel">set_channel</a></code></li>
<li><code><a title="scripts.beaconSpam.WifiSpammer.start_scan" href="#scripts.beaconSpam.WifiSpammer.start_scan">start_scan</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
