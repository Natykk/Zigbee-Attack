<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>scripts.beaconSpam API documentation</title>
<meta name="description" content="Ce module implémente un spammer de paquets Beacon WiFi. Il permet de configurer une interface réseau pour envoyer des paquets Beacon sur un canal …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scripts.beaconSpam</code></h1>
</header>
<section id="section-intro">
<p>Ce module implémente un spammer de paquets Beacon WiFi. Il permet de configurer une interface réseau pour envoyer des paquets Beacon sur un canal spécifique, surveiller le nombre de paquets envoyés, et gérer l'envoi en utilisant des threads.</p>
<h2 id="classes">Classes</h2>
<p>WifiSpammer : Classe pour gérer l'envoi de paquets Beacon WiFi.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scripts.beaconSpam.WifiSpammer"><code class="flex name class">
<span>class <span class="ident">WifiSpammer</span></span>
<span>(</span><span>interface: str,<br>channel: int = 1,<br>ssid: str = 'TestSSID',<br>max_queue_size: int = 1000)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WifiSpammer:
    &#34;&#34;&#34;
    Classe pour spammer le réseau WiFi avec des paquets Beacon.

    Attributes
    ----------
    interface : str
        Interface réseau à utiliser pour l&#39;envoi des paquets.
    channel : int
        Canal WiFi sur lequel envoyer les paquets Beacon.
    ssid : str
        SSID à diffuser dans les paquets Beacon.
    packet_queue : queue.Queue
        File d&#39;attente des paquets à envoyer.
    running : bool
        Indicateur d&#39;état de fonctionnement de l&#39;envoi des paquets.
    sent_count : int
        Nombre de paquets envoyés.
    start_time : float
        Heure de début de l&#39;envoi des paquets, utilisée pour calculer le taux d&#39;envoi.
    &#34;&#34;&#34;

    def __init__(self, interface: str, channel: int = 1, ssid: str = &#34;TestSSID&#34;, max_queue_size: int = 1000):
        &#34;&#34;&#34;
        Initialise un spammer WiFi.

        Parameters
        ----------
        interface : str
            Interface réseau à utiliser pour l&#39;envoi des paquets.
        channel : int, optional
            Canal WiFi sur lequel les paquets Beacon seront envoyés (par défaut : 1).
        ssid : str, optional
            SSID à diffuser dans les paquets Beacon (par défaut : &#34;TestSSID&#34;).
        max_queue_size : int, optional
            Taille maximale de la file d&#39;attente pour les paquets (par défaut : 1000).
        &#34;&#34;&#34;
        self.interface = interface
        self.channel = channel
        self.ssid = ssid
        self.packet_queue = Queue(maxsize=max_queue_size)
        self.running = False
        self.sent_count = 0
        self.start_time = 0

    def set_channel(self):
        &#34;&#34;&#34;
        Configure l&#39;interface WiFi sur le canal spécifié.

        Raises
        ------
        Exception
            Si une erreur survient lors de la configuration du canal.
        &#34;&#34;&#34;
        try:
            # os.system(f&#34;iwconfig {self.interface} channel {self.channel}&#34;)
            print(f&#34;Canal configuré sur {self.channel}&#34;)
        except Exception as e:
            print(f&#34;Erreur lors de la configuration du canal : {e}&#34;)

    def create_beacon_packet(self) -&gt; RadioTap:
        &#34;&#34;&#34;
        Crée un paquet Beacon WiFi.

        Returns
        -------
        scapy.layers.dot11.RadioTap
            Un paquet RadioTap contenant un Beacon WiFi configuré avec le SSID et le canal.
        &#34;&#34;&#34;
        return (RadioTap()
                / Dot11(type=0, subtype=8,
                        addr1=&#39;ff:ff:ff:ff:ff:ff&#39;,
                        addr2=&#39;00:11:22:33:44:55&#39;,
                        addr3=&#39;ff:ff:ff:ff:ff:ff&#39;)
                / Dot11Beacon(cap=&#39;ESS&#39;)
                / Dot11Elt(ID=&#39;SSID&#39;, info=self.ssid)
                / Dot11Elt(ID=&#39;DSset&#39;, info=chr(self.channel)))

    def packet_sender(self):
        &#34;&#34;&#34;
        Gère l&#39;envoi des paquets Beacon en continu.

        Notes
        -----
        Cette méthode est exécutée dans un thread pour envoyer les paquets Beacon par lots de 10.
        &#34;&#34;&#34;
        beacon_packet = self.create_beacon_packet()

        while self.running:
            try:
                sendp(beacon_packet, iface=self.interface, verbose=False, count=10)
                with threading.Lock():
                    self.sent_count += 10
            except Exception as e:
                print(f&#34;Erreur lors de l&#39;envoi du paquet : {e}&#34;)
                time.sleep(0.1)  # Temporisation en cas d&#39;erreur

    def monitor_progress(self):
        &#34;&#34;&#34;
        Surveille la progression de l&#39;envoi des paquets Beacon.

        Affiche en temps réel le nombre de paquets envoyés et le taux d&#39;envoi en paquets par seconde.
        &#34;&#34;&#34;
        while self.running:
            elapsed_time = time.time() - self.start_time
            rate = self.sent_count / elapsed_time if elapsed_time &gt; 0 else 0
            print(f&#34;Envoyé {self.sent_count} paquets sur le canal {self.channel} | Taux : {rate:.2f} paquets/sec&#34;)
            time.sleep(1)

    def start_scan(self, num_sender_threads: int = 4):
        &#34;&#34;&#34;
        Démarre le processus d&#39;envoi des paquets Beacon.

        Parameters
        ----------
        num_sender_threads : int, optional
            Nombre de threads utilisés pour envoyer les paquets (par défaut : 4).

        Notes
        -----
        Configure le canal WiFi, lance plusieurs threads pour envoyer les paquets et démarre un thread pour surveiller
        le progrès de l&#39;envoi.
        &#34;&#34;&#34;
        self.set_channel()

        self.running = True
        self.start_time = time.time()

        sender_threads = []
        for _ in range(num_sender_threads):
            thread = threading.Thread(target=self.packet_sender)
            thread.daemon = True
            thread.start()
            sender_threads.append(thread)

        monitor_thread = threading.Thread(target=self.monitor_progress)
        monitor_thread.daemon = True
        monitor_thread.start()

        try:
            while True:
                time.sleep(0.1)
        except KeyboardInterrupt:
            print(&#34;\nArrêt du scan...&#34;)
            self.running = False

            for thread in sender_threads:
                thread.join()
            monitor_thread.join()</code></pre>
</details>
<div class="desc"><p>Classe pour spammer le réseau WiFi avec des paquets Beacon.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>interface</code></strong> :&ensp;<code>str</code></dt>
<dd>Interface réseau à utiliser pour l'envoi des paquets.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code></dt>
<dd>Canal WiFi sur lequel envoyer les paquets Beacon.</dd>
<dt><strong><code>ssid</code></strong> :&ensp;<code>str</code></dt>
<dd>SSID à diffuser dans les paquets Beacon.</dd>
<dt><strong><code>packet_queue</code></strong> :&ensp;<code>queue.Queue</code></dt>
<dd>File d'attente des paquets à envoyer.</dd>
<dt><strong><code>running</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicateur d'état de fonctionnement de l'envoi des paquets.</dd>
<dt><strong><code>sent_count</code></strong> :&ensp;<code>int</code></dt>
<dd>Nombre de paquets envoyés.</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>float</code></dt>
<dd>Heure de début de l'envoi des paquets, utilisée pour calculer le taux d'envoi.</dd>
</dl>
<p>Initialise un spammer WiFi.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>interface</code></strong> :&ensp;<code>str</code></dt>
<dd>Interface réseau à utiliser pour l'envoi des paquets.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Canal WiFi sur lequel les paquets Beacon seront envoyés (par défaut : 1).</dd>
<dt><strong><code>ssid</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>SSID à diffuser dans les paquets Beacon (par défaut : "TestSSID").</dd>
<dt><strong><code>max_queue_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Taille maximale de la file d'attente pour les paquets (par défaut : 1000).</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="scripts.beaconSpam.WifiSpammer.create_beacon_packet"><code class="name flex">
<span>def <span class="ident">create_beacon_packet</span></span>(<span>self) ‑> scapy.layers.dot11.RadioTap</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_beacon_packet(self) -&gt; RadioTap:
    &#34;&#34;&#34;
    Crée un paquet Beacon WiFi.

    Returns
    -------
    scapy.layers.dot11.RadioTap
        Un paquet RadioTap contenant un Beacon WiFi configuré avec le SSID et le canal.
    &#34;&#34;&#34;
    return (RadioTap()
            / Dot11(type=0, subtype=8,
                    addr1=&#39;ff:ff:ff:ff:ff:ff&#39;,
                    addr2=&#39;00:11:22:33:44:55&#39;,
                    addr3=&#39;ff:ff:ff:ff:ff:ff&#39;)
            / Dot11Beacon(cap=&#39;ESS&#39;)
            / Dot11Elt(ID=&#39;SSID&#39;, info=self.ssid)
            / Dot11Elt(ID=&#39;DSset&#39;, info=chr(self.channel)))</code></pre>
</details>
<div class="desc"><p>Crée un paquet Beacon WiFi.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>scapy.layers.dot11.RadioTap</code></dt>
<dd>Un paquet RadioTap contenant un Beacon WiFi configuré avec le SSID et le canal.</dd>
</dl></div>
</dd>
<dt id="scripts.beaconSpam.WifiSpammer.monitor_progress"><code class="name flex">
<span>def <span class="ident">monitor_progress</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def monitor_progress(self):
    &#34;&#34;&#34;
    Surveille la progression de l&#39;envoi des paquets Beacon.

    Affiche en temps réel le nombre de paquets envoyés et le taux d&#39;envoi en paquets par seconde.
    &#34;&#34;&#34;
    while self.running:
        elapsed_time = time.time() - self.start_time
        rate = self.sent_count / elapsed_time if elapsed_time &gt; 0 else 0
        print(f&#34;Envoyé {self.sent_count} paquets sur le canal {self.channel} | Taux : {rate:.2f} paquets/sec&#34;)
        time.sleep(1)</code></pre>
</details>
<div class="desc"><p>Surveille la progression de l'envoi des paquets Beacon.</p>
<p>Affiche en temps réel le nombre de paquets envoyés et le taux d'envoi en paquets par seconde.</p></div>
</dd>
<dt id="scripts.beaconSpam.WifiSpammer.packet_sender"><code class="name flex">
<span>def <span class="ident">packet_sender</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def packet_sender(self):
    &#34;&#34;&#34;
    Gère l&#39;envoi des paquets Beacon en continu.

    Notes
    -----
    Cette méthode est exécutée dans un thread pour envoyer les paquets Beacon par lots de 10.
    &#34;&#34;&#34;
    beacon_packet = self.create_beacon_packet()

    while self.running:
        try:
            sendp(beacon_packet, iface=self.interface, verbose=False, count=10)
            with threading.Lock():
                self.sent_count += 10
        except Exception as e:
            print(f&#34;Erreur lors de l&#39;envoi du paquet : {e}&#34;)
            time.sleep(0.1)  # Temporisation en cas d&#39;erreur</code></pre>
</details>
<div class="desc"><p>Gère l'envoi des paquets Beacon en continu.</p>
<h2 id="notes">Notes</h2>
<p>Cette méthode est exécutée dans un thread pour envoyer les paquets Beacon par lots de 10.</p></div>
</dd>
<dt id="scripts.beaconSpam.WifiSpammer.set_channel"><code class="name flex">
<span>def <span class="ident">set_channel</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_channel(self):
    &#34;&#34;&#34;
    Configure l&#39;interface WiFi sur le canal spécifié.

    Raises
    ------
    Exception
        Si une erreur survient lors de la configuration du canal.
    &#34;&#34;&#34;
    try:
        # os.system(f&#34;iwconfig {self.interface} channel {self.channel}&#34;)
        print(f&#34;Canal configuré sur {self.channel}&#34;)
    except Exception as e:
        print(f&#34;Erreur lors de la configuration du canal : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Configure l'interface WiFi sur le canal spécifié.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Si une erreur survient lors de la configuration du canal.</dd>
</dl></div>
</dd>
<dt id="scripts.beaconSpam.WifiSpammer.start_scan"><code class="name flex">
<span>def <span class="ident">start_scan</span></span>(<span>self, num_sender_threads: int = 4)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_scan(self, num_sender_threads: int = 4):
    &#34;&#34;&#34;
    Démarre le processus d&#39;envoi des paquets Beacon.

    Parameters
    ----------
    num_sender_threads : int, optional
        Nombre de threads utilisés pour envoyer les paquets (par défaut : 4).

    Notes
    -----
    Configure le canal WiFi, lance plusieurs threads pour envoyer les paquets et démarre un thread pour surveiller
    le progrès de l&#39;envoi.
    &#34;&#34;&#34;
    self.set_channel()

    self.running = True
    self.start_time = time.time()

    sender_threads = []
    for _ in range(num_sender_threads):
        thread = threading.Thread(target=self.packet_sender)
        thread.daemon = True
        thread.start()
        sender_threads.append(thread)

    monitor_thread = threading.Thread(target=self.monitor_progress)
    monitor_thread.daemon = True
    monitor_thread.start()

    try:
        while True:
            time.sleep(0.1)
    except KeyboardInterrupt:
        print(&#34;\nArrêt du scan...&#34;)
        self.running = False

        for thread in sender_threads:
            thread.join()
        monitor_thread.join()</code></pre>
</details>
<div class="desc"><p>Démarre le processus d'envoi des paquets Beacon.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_sender_threads</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Nombre de threads utilisés pour envoyer les paquets (par défaut : 4).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Configure le canal WiFi, lance plusieurs threads pour envoyer les paquets et démarre un thread pour surveiller
le progrès de l'envoi.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#classes">Classes</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scripts" href="index.html">scripts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scripts.beaconSpam.WifiSpammer" href="#scripts.beaconSpam.WifiSpammer">WifiSpammer</a></code></h4>
<ul class="">
<li><code><a title="scripts.beaconSpam.WifiSpammer.create_beacon_packet" href="#scripts.beaconSpam.WifiSpammer.create_beacon_packet">create_beacon_packet</a></code></li>
<li><code><a title="scripts.beaconSpam.WifiSpammer.monitor_progress" href="#scripts.beaconSpam.WifiSpammer.monitor_progress">monitor_progress</a></code></li>
<li><code><a title="scripts.beaconSpam.WifiSpammer.packet_sender" href="#scripts.beaconSpam.WifiSpammer.packet_sender">packet_sender</a></code></li>
<li><code><a title="scripts.beaconSpam.WifiSpammer.set_channel" href="#scripts.beaconSpam.WifiSpammer.set_channel">set_channel</a></code></li>
<li><code><a title="scripts.beaconSpam.WifiSpammer.start_scan" href="#scripts.beaconSpam.WifiSpammer.start_scan">start_scan</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
