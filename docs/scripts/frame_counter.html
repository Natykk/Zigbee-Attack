<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>frame_counter API documentation</title>
<meta name="description" content="Module pour la gestion du frame counter et du numéro de séquence dans les trames Zigbee.
Ce module fournit des méthodes permettant d&#39;incrémenter le …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>frame_counter</code></h1>
</header>
<section id="section-intro">
<p>Module pour la gestion du frame counter et du numéro de séquence dans les trames Zigbee.
Ce module fournit des méthodes permettant d'incrémenter le frame counter et le numéro de séquence
dans une trame Zigbee, tout en garantissant que la longueur de la trame reste constante.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="frame_counter.ZigbeeFrameFinder"><code class="flex name class">
<span>class <span class="ident">ZigbeeFrameFinder</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZigbeeFrameFinder:
    def increment_frame_counter(self, trame_hex: str, increment: int = 10) -&gt; str:
        &#34;&#34;&#34;
        Incrémente le frame counter dans une trame Zigbee.

        Cette méthode extrait le frame counter (situé dans les 8 derniers caractères de la trame,
        plus précisément les 7e et 8e octets depuis la fin) et y ajoute une valeur d&#39;incrément spécifiée.
        Le nouveau frame counter est alors converti en représentation hexadécimale (sur un octet en little-endian)
        et réintégré dans la trame à la même position, garantissant ainsi que la longueur de la trame reste inchangée.

        Args:
            trame_hex (str): La trame Zigbee au format hexadécimal.
            increment (int): La valeur à ajouter au frame counter (par défaut 10).

        Returns:
            str: La nouvelle trame avec le frame counter incrémenté.

        Raises:
            ValueError: Si la longueur de la trame change après l&#39;incrémentation,
                        ce qui indiquerait une erreur dans le format de la trame.
        &#34;&#34;&#34;
        current_fc = trame_hex[-8:-6]
        # Calcul du nouveau frame counter
        new_fc = int(current_fc, 16) + increment

        # Conversion en bytes (sur 1 octet, little-endian) puis en hex
        new_fc_hex = new_fc.to_bytes(1, byteorder=&#39;little&#39;).hex()

        # Reconstruction de la trame avec le nouveau frame counter
        new_trame = trame_hex[:-8] + new_fc_hex + trame_hex[-6:]
        if len(trame_hex) == len(new_trame):
            return new_trame
        else:
            raise ValueError(&#34;La longueur de la trame a changé après l&#39;incrémentation du frame counter.&#34;)

    def increment_sequence_number(self, trame_hex: str, increment: int = 1) -&gt; str:
        &#34;&#34;&#34;
        Incrémente le numéro de séquence dans une trame Zigbee.

        Cette méthode extrait le numéro de séquence (les 4 derniers caractères de la trame,
        plus précisément les 3e et 4e octets depuis la fin), y ajoute la valeur d&#39;incrément, 
        et reconstruit la trame en alternant la valeur du dernier octet selon une règle définie :
            - Si le dernier octet est &#39;0&#39;(off), il est remplacé par &#39;01&#39;(on).
            - Si le dernier octet est &#39;1&#39;(on), il est remplacé par &#39;00&#39;(off).
            - Sinon, &#39;02&#39;(toggle).

        Cette logique permet de gérer une alternance ou une alternance conditionnelle dans la trame.

        Args:
            trame_hex (str): La trame Zigbee au format hexadécimal.
            increment (int): La valeur à ajouter au numéro de séquence (par défaut 1).

        Returns:
            str: La nouvelle trame avec le numéro de séquence incrémenté.
        &#34;&#34;&#34;
        current_sequence_number = trame_hex[-4:-2]
        # Incrémenter le numéro de séquence
        current_sequence_number = int(current_sequence_number, 16) + increment
        new_sequence_number = current_sequence_number.to_bytes(1, byteorder=&#39;little&#39;).hex()

        # Alternance basée sur la valeur du dernier octet
        if trame_hex[-1] == &#39;0&#39;:
            return trame_hex[:-4] + new_sequence_number + &#39;01&#39;
        elif trame_hex[-1] == &#39;1&#39;:
            return trame_hex[:-4] + new_sequence_number + &#39;00&#39;
        else:
            return trame_hex[:-4] + new_sequence_number + &#39;02&#39;</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="frame_counter.ZigbeeFrameFinder.increment_frame_counter"><code class="name flex">
<span>def <span class="ident">increment_frame_counter</span></span>(<span>self, trame_hex: str, increment: int = 10) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increment_frame_counter(self, trame_hex: str, increment: int = 10) -&gt; str:
    &#34;&#34;&#34;
    Incrémente le frame counter dans une trame Zigbee.

    Cette méthode extrait le frame counter (situé dans les 8 derniers caractères de la trame,
    plus précisément les 7e et 8e octets depuis la fin) et y ajoute une valeur d&#39;incrément spécifiée.
    Le nouveau frame counter est alors converti en représentation hexadécimale (sur un octet en little-endian)
    et réintégré dans la trame à la même position, garantissant ainsi que la longueur de la trame reste inchangée.

    Args:
        trame_hex (str): La trame Zigbee au format hexadécimal.
        increment (int): La valeur à ajouter au frame counter (par défaut 10).

    Returns:
        str: La nouvelle trame avec le frame counter incrémenté.

    Raises:
        ValueError: Si la longueur de la trame change après l&#39;incrémentation,
                    ce qui indiquerait une erreur dans le format de la trame.
    &#34;&#34;&#34;
    current_fc = trame_hex[-8:-6]
    # Calcul du nouveau frame counter
    new_fc = int(current_fc, 16) + increment

    # Conversion en bytes (sur 1 octet, little-endian) puis en hex
    new_fc_hex = new_fc.to_bytes(1, byteorder=&#39;little&#39;).hex()

    # Reconstruction de la trame avec le nouveau frame counter
    new_trame = trame_hex[:-8] + new_fc_hex + trame_hex[-6:]
    if len(trame_hex) == len(new_trame):
        return new_trame
    else:
        raise ValueError(&#34;La longueur de la trame a changé après l&#39;incrémentation du frame counter.&#34;)</code></pre>
</details>
<div class="desc"><p>Incrémente le frame counter dans une trame Zigbee.</p>
<p>Cette méthode extrait le frame counter (situé dans les 8 derniers caractères de la trame,
plus précisément les 7e et 8e octets depuis la fin) et y ajoute une valeur d'incrément spécifiée.
Le nouveau frame counter est alors converti en représentation hexadécimale (sur un octet en little-endian)
et réintégré dans la trame à la même position, garantissant ainsi que la longueur de la trame reste inchangée.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trame_hex</code></strong> :&ensp;<code>str</code></dt>
<dd>La trame Zigbee au format hexadécimal.</dd>
<dt><strong><code>increment</code></strong> :&ensp;<code>int</code></dt>
<dd>La valeur à ajouter au frame counter (par défaut 10).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>La nouvelle trame avec le frame counter incrémenté.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Si la longueur de la trame change après l'incrémentation,
ce qui indiquerait une erreur dans le format de la trame.</dd>
</dl></div>
</dd>
<dt id="frame_counter.ZigbeeFrameFinder.increment_sequence_number"><code class="name flex">
<span>def <span class="ident">increment_sequence_number</span></span>(<span>self, trame_hex: str, increment: int = 1) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increment_sequence_number(self, trame_hex: str, increment: int = 1) -&gt; str:
    &#34;&#34;&#34;
    Incrémente le numéro de séquence dans une trame Zigbee.

    Cette méthode extrait le numéro de séquence (les 4 derniers caractères de la trame,
    plus précisément les 3e et 4e octets depuis la fin), y ajoute la valeur d&#39;incrément, 
    et reconstruit la trame en alternant la valeur du dernier octet selon une règle définie :
        - Si le dernier octet est &#39;0&#39;(off), il est remplacé par &#39;01&#39;(on).
        - Si le dernier octet est &#39;1&#39;(on), il est remplacé par &#39;00&#39;(off).
        - Sinon, &#39;02&#39;(toggle).

    Cette logique permet de gérer une alternance ou une alternance conditionnelle dans la trame.

    Args:
        trame_hex (str): La trame Zigbee au format hexadécimal.
        increment (int): La valeur à ajouter au numéro de séquence (par défaut 1).

    Returns:
        str: La nouvelle trame avec le numéro de séquence incrémenté.
    &#34;&#34;&#34;
    current_sequence_number = trame_hex[-4:-2]
    # Incrémenter le numéro de séquence
    current_sequence_number = int(current_sequence_number, 16) + increment
    new_sequence_number = current_sequence_number.to_bytes(1, byteorder=&#39;little&#39;).hex()

    # Alternance basée sur la valeur du dernier octet
    if trame_hex[-1] == &#39;0&#39;:
        return trame_hex[:-4] + new_sequence_number + &#39;01&#39;
    elif trame_hex[-1] == &#39;1&#39;:
        return trame_hex[:-4] + new_sequence_number + &#39;00&#39;
    else:
        return trame_hex[:-4] + new_sequence_number + &#39;02&#39;</code></pre>
</details>
<div class="desc"><p>Incrémente le numéro de séquence dans une trame Zigbee.</p>
<p>Cette méthode extrait le numéro de séquence (les 4 derniers caractères de la trame,
plus précisément les 3e et 4e octets depuis la fin), y ajoute la valeur d'incrément,
et reconstruit la trame en alternant la valeur du dernier octet selon une règle définie :
- Si le dernier octet est '0'(off), il est remplacé par '01'(on).
- Si le dernier octet est '1'(on), il est remplacé par '00'(off).
- Sinon, '02'(toggle).</p>
<p>Cette logique permet de gérer une alternance ou une alternance conditionnelle dans la trame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trame_hex</code></strong> :&ensp;<code>str</code></dt>
<dd>La trame Zigbee au format hexadécimal.</dd>
<dt><strong><code>increment</code></strong> :&ensp;<code>int</code></dt>
<dd>La valeur à ajouter au numéro de séquence (par défaut 1).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>La nouvelle trame avec le numéro de séquence incrémenté.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="frame_counter.ZigbeeFrameFinder" href="#frame_counter.ZigbeeFrameFinder">ZigbeeFrameFinder</a></code></h4>
<ul class="">
<li><code><a title="frame_counter.ZigbeeFrameFinder.increment_frame_counter" href="#frame_counter.ZigbeeFrameFinder.increment_frame_counter">increment_frame_counter</a></code></li>
<li><code><a title="frame_counter.ZigbeeFrameFinder.increment_sequence_number" href="#frame_counter.ZigbeeFrameFinder.increment_sequence_number">increment_sequence_number</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
