# -*- coding: utf-8 -*-
"""ZigBee encryption with AES-128-CCM*.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UPn0uvd84aItSYZRJd59PV026M6S1Mzy

# ZigBee frame encryption with AES-128-CCM*

This notebook details how to encrypt ZigBee frames with AES-128-CCM*. Zigbee encryption is performed in three stages:
* Input transformation (prepare data)
* Authentication Transformation (generate MIC)
* Encryption Transformation (returns encrypted frame)

The frame used in this example is a frame listen on a real ZigBee network detailed on this page: [Autopsy of a ZigBee frame](https://lucidar.me/en/zigbee/autopsy-of-a-zigbee-frame/).

The algorithm is detailed in the [section 4.3.1.1](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=404&zoom=100,93,0) and [annex A of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=479&zoom=100,93,0).


More details on [Philippe Lucidarme's blog](lucidar.me/en/zigbee/zigbee-frame-encryption-with-aes-128-ccm/)

## Libraries and functions

Here are the libraries and functions used in the following:
"""

#!pip install pycryptodome

# Python Cryptography Toolkit for AES encryption
from Crypto.Cipher import AES

# Print aray of bytes in hexadecimal
def printhex(x, sep = ' '):
  str = ''
  for b in x:  
    byte = hex(b)[2:]
    if (len(byte)<2)  :
      str += '0' + byte + sep
    else:
      str += hex(b)[2:] + sep 
  print (str[:-1].upper())


# 16 bits padding (with 0x00)
def pad(x):
  n=(16-len(x)%16)%16
  return x + bytes([0x00]*n)

"""## Network key

According to [annex A.2 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=479&zoom=100,93,650):

> *A bit string Key of length keylen bits to be used as the key. Each entity shall have evidence that access to this key is restricted to the entity itself and its intended key-sharing group member(s).*

In this example, the network key has been previously listen on the network thank this [ZigBee sniffer](https://lucidar.me/en/zigbee/zigbee-sniffer/):

**Network key:** ```AD:8E:BB:C4:F9:6A:E7:00:05:06:D3:FC:D1:62:7F:B8```
"""

key =   bytes([0xAD, 0x8E, 0xBB, 0xC4, 0xF9, 0x6A, 0xE7, 0x00, 0x05, 0x06, 0xD3, 0xFC, 0xD1, 0x62, 0x7F, 0xB8])
printhex (key)

"""## L of the message length field

According to [annex A of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=479&zoom=100,93,350):

> *The length L of the message length field, in octets, shall have been chosen. Valid values for L are the integers 2, 3,..., 8 (the value L=1 is reserved).*

In the present case, L=2.
"""

L = 2

"""## M (length of frame integrity)

According to [annex A of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=479&zoom=100,93,350):

> *The length M of the authentication field, in octets, shall have been chosen. Valid values for M are the integers 0, 4, 6, 8, 10, 12, 14, and 16. (The value M=0 corresponds to disabling authenticity, since then the authentication field contains an empty string.)*

M is the length of the [frame integrity (MIC)](https://lucidar.me/en/zigbee/autopsy-of-a-zigbee-frame/#nwk-mic) in number of bytes.  In the present case, and from [section 4.5.1.1.1 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=448&zoom=100,0,240), we can deduce the length of M is 4 bytes: ```AC:4C:76:AF```.
"""

M=4

"""## NWK header

The NWK header (network header) is extracted from the [raw frame](https://lucidar.me/en/zigbee/autopsy-of-a-zigbee-frame/#nwk-header):

**NWK header:** ```48:02:00:00:8A:5C:1E:5D```

"""

NwkHeader = bytes([0x48, 0x1A, 0x00, 0x00, 0x9B, 0x9A, 0x30, 0x45])
printhex (NwkHeader)

"""## NWK AUX Header

According to [section 4.5.1 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=447&zoom=100,93,598)

> The auxiliary frame header, as illustrated by Figure 4.18, shall include a security control field and a frame counter field, and may include a sender address field and key sequence number field. 

| Octets: 1 | 4 | 0/8 | 0/1 |
| --- | --- | --- | --- |
| Security control | Frame counter | Source address | Key sequence number |

* **Security control:** ```2D``` => (ENC-MIC-32) See [section 4.5.1.1.1 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=448&zoom=100,0,240) for more details)
* **Frame counter:** ```E1``` 
* **Source address:** ```00:15:8D:00:01:E8:3C:01```
* **Key sequence:** ```01```

More details on the [section about NWK auxiliary header](https://lucidar.me/en/zigbee/autopsy-of-a-zigbee-frame/#nwk-aux-header).
"""

AuxiliaryHeader = bytes([0x28, 0x10, 0xE4, 0x00, 0xFE, 0x60, 0x28, 0x9E])
printhex (AuxiliaryHeader)

"""## Nonce

According to [section 4.5.2.2 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=450&zoom=100,93,96):

> *The nonce input used for the CCM encryption and authentication transformation and for the CCM decryption and authentication checking transformation consists of data explicitly included in the frame and data that both devices can independently obtain.*

| Octets: 8 | 4 | 1 |
| --- | --- | --- |
|Source address | Frame counter | Security control |

* **Source address:** ```00:15:8D:00:01:E8:3C:01```
* **Frame counter:** ```E1```
* **Security control:** ```2D``` => (ENC-MIC-32) See [section 4.5.1.1.1 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=448&zoom=100,0,240) for more details)
"""

nonce = bytes([0x74, 0x4D, 0xBD, 0xFF, 0xFE, 0x60, 0x28, 0x9E, 0x10, 0xE4, 0x00, 0x00, 0x28])
print (len(nonce), 'bytes')
printhex (nonce)

"""## a and m

From [section 4.3.1.1 from the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=404&zoom=100,93,540):

> *If the security level requires encryption, the octet string **a shall be the string NwkHeader || AuxiliaryHeader** and the octet string **m shall be the string Payload**. *

Since in our case, security level requires encryption:

a = [NwkHeader](https://lucidar.me/en/zigbee/autopsy-of-a-zigbee-frame/#nwk-header) || [AuxiliaryHeader](https://lucidar.me/en/zigbee/autopsy-of-a-zigbee-frame/#nwk-aux-header)

m = payload (The payload contains the data sent by the switch, see [section NWK payload](https://lucidar.me/en/zigbee/autopsy-of-a-zigbee-frame/#nwk-payload) for more details)
"""

# Octet string a
a = NwkHeader + AuxiliaryHeader
print ('a:')
printhex (a)

# Octet string m
print ('\nm:')
m = bytes([0xBD, 0xCA, 0x72, 0x94, 0x1C, 0x91, 0xCB, 0x9E, 0x9F, 0xA9, 0xCF])
printhex(m)

"""## AddAuthData

From [annex A.2.1 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=480&zoom=100,93,300):

> 1. *Form the octet string representation L(a) of the length l(a) of the octet 
string a.* [...]
> 2. *Right-concatenate the octet string L(a) with the octet string a itself. Note that the resulting string contains and a encoded in a reversible manner.*
> 3. *Form the padded message AddAuthData by right-concatenating the resulting string with the smallest non-negative number of all-zero octets such that the octet string AddAuthData has length divisible by 16.*

In the present case (case b in the ZigBee specification),  L(a) is the 2-octets encoding of l(a).
"""

# Right-concatenate the octet string L(a) with the octet string a itself.
AddAuthData = len(a).to_bytes(2, byteorder = 'big') + a
# Form the padded message AddAuthData
AddAuthData = pad(AddAuthData)

print(len(AddAuthData), 'bytes')
printhex(AddAuthData)

"""## PlaintextData

From [annex A.2.1 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=480&zoom=100,93,300):

> *Form the padded message PlaintextData by right-concatenating the octet string m with the smallest non-negative number of all-zero octets such that the octet string PlaintextData has length divisible by 16.*
"""

PlaintextData = m
# Padding (not necessary here, because length(m)=16)
PlaintextData = pad(PlaintextData)

print (len(PlaintextData), 'bytes')
printhex (PlaintextData)

"""## AuthData

From [annex A.2.1 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=480&zoom=100,93,300):

> *Form the message AuthData consisting of the octet strings AddAuthData and PlaintextData:* 
>
> **AuthData = AddAuthData || PlaintextData**

Note that ```AuthData``` is part of the input string of the EAS-CBC algorithm and can be truncated into 16 bytes segments for AES:

AuthData = B1 || B2 || B3 || B4
"""

AuthData = AddAuthData + PlaintextData
print (len(AuthData), 'bytes')
printhex (AuthData)

"""## Flags

The 1-octet flags is created according to [section A.2.2 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=480&zoom=100,93,610):


> _Form the 1-octet Flags field consisting of the 1-bit Reserved field, the 1-bit Adata field, and the 3-bit representations of the integers M and L, as follows:_
>
> _Flags = Reserved || Adata || M || L_
>
> _Here, the 1-bit Reserved field is reserved for future expansions and shall be set to ‘0’._

**Reserved = 0b0**

> _The 1-bit Adata field is set to ‘0’ if l(a)=0, and set to ‘1’ if l(a)>0. _

**Adata = 0b1** since l(a)=22


> _The L field is the 3-bit representation of the integer L-1, in most-significant-bit-first order._

Since L=2, L-1=1 => **L field = 001** 

>_The M field is the 3-bit representation of the integer (M-2)/2 if M>0 and of the integer 0 if M=0, in most-significant-bit-first order_

Since M=4, M-2/2=1 => **M field = 001**

In conclusion :

**Flags = 0b01001001 = 0x49**

"""

Flags = bytes([0x49]) # = ([0b01001001])
printhex (Flags)

"""## B0

B0 is the first 16 bytes input of the AES algorithm. According to [section A.2.2 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=480&zoom=100,93,800):

> *Form the 16-octet B0 field consisting of the 1-octet Flags field defined above, the 15-L octet nonce field N, and the L-octet representation of the length field l(m), as follows:*
>
> _B0 = Flags || Nonce N || l(m)_

"""

B0 = Flags + nonce + len(m).to_bytes(2, byteorder = 'big')
print ('Should be 16 bytes =>', len(B0), 'bytes')
printhex (B0)

"""## X0

According to [section A.2.2 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=480&zoom=100,93,855):

> _Parse the message AuthData as B1 || B2 || ... ||Bt, where each message block Bi is a 16-octet string. The CBC-MAC value Xt+1 is defined by:_
>
> _X0: = 0b0 (x128); Xi+1:= E(Key, Xi ⊕ Bi) for i=0, ... , t._


X0 is initialized with:

**X0 = 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00**

"""

X0 = bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
printhex(X0)

"""## Authentication tag T (MIC)

In this section, the message integrity code (MIC) is generated. 
According to [section A.2.2 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=480&zoom=100,93,855), the algorithm used for encryption is AES-128-CBC. Instead of processing groups of 16 bytes (B0, B1, B2 ...), we use here the [Python Cryptography Toolkit](https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html) for encryption with the following parameters:

* mode (encryption algorithm) = AES-CBC
* IV = X0
* Raw data = B0 || AuthData

The MIC generated is ```AC 4C 76 AF``` which is the expected [NWK MIC](https://lucidar.me/fr/zigbee/autopsy-of-a-zigbee-frame/#nwk-mic).

"""

cipher = AES.new(key, AES.MODE_CBC, X0)
X1 = cipher.encrypt(B0 + AuthData)
T = X1[-16:-12]
print ('MIC = ')
printhex (T)

"""## Encryption transformation

The last part of the process is the encryption transformation based on [Section A.2.3 of the Zigbee Specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=481&zoom=100,93,130).

The first step is to build the 1-octet Flags:

> _Form the 1-octet Flags field consisting of two 1-bit Reserved fields, and the 3- bit representations of the integers 0 and L, as follows:_
>
> _Flags = Reserved || Reserved || 0 || L_
>
> _Here, the two 1-bit Reserved fields are reserved for future expansions and shall be set to ‘0’. The L field is the 3-bit representation of the integer L-1, in most-significant- bit-first order. The ‘0’ field is the 3-bit representation of the integer 0, in most-significant-bit-first order._

In our case, L=2 => L-1 = 1
"""

Flags = bytes ([0b00000001])
printhex (Flags)

"""## Ai

According to [section A.2.3 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=481&zoom=100,93,317), the 16-octet Ai are built with the following method:

> _Define the 16-octet Ai field consisting of the 1-octet Flags field defined above, the 15-L octet nonce field N, and the L-octet representation of the integer i, as follows:_
>
> _Ai = Flags || Nonce N || Counter i, for i=0, 1, 2, …_
>
> _Note that this definition ensures that all the Ai fields are distinct from the B0 fields that are actually used, as those have a Flags field with a non-zero encoding of M in the positions where all Ai fields have an all-zero encoding of the integer 0 (see section A.2.2, step 1)._

Since ```PlaintextData``` is a 16-bytes length, we only need A0 and A1.
* A0 is for MIC encryption (tag U)
* A1 is for generating Ciphertext
"""

A0 = Flags + nonce + bytes([0x00, 0x00])
A1 = Flags + nonce + bytes([0x00, 0x01])
printhex (A0)
printhex (A1)

"""## AES CTR

The algorithm used for encrypting the payload is AES-CTR. Here, we use the [Python Cryptography Toolkit](https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html) that supports AES-CTR. Since `PlaintextData` is only 16 bytes, we cheat the CTR counter by always returning A1.

According to the [Raw encrypted frame](https://lucidar.me/en/zigbee/autopsy-of-a-zigbee-frame/#raw-frames) listened on the network, the expected encrypted data is:

**Expected encrypted payload:** ```EA 59 DE 1F 96 0E EA 8A EE 18 5A 11 89 30 96 41```

"""

from Crypto.Util import Counter  
ctr = Counter.new(128, initial_value = int.from_bytes(A1, "big"))
cipher = AES.new(key, AES.MODE_CTR, counter = ctr)
Ciphertext = cipher.encrypt(PlaintextData)
print ('CipherText = ')
printhex (Ciphertext)

"""## Encrypted authentication tag U

The last part of the encryption is the tag U (encrypted message integrity code):

According to [section A.2.3 of the ZigBee specification](https://lucidar.me/en/zigbee/files/docs-05-3474-21-0csg-zigbee-specification.pdf#page=481&zoom=100,93,500), the authentification tag is built according to the following:

> _Define the 16-octet encryption block S0 by:_
>
> _S0:= E(Key, A0)_
>
> _The encrypted authentication tag U is the result of XOR-ing the string consisting of the leftmost M octets of S0 and the authentication tag T._

According to the [raw encrypted frame](https://lucidar.me/en/zigbee/autopsy-of-a-zigbee-frame/#raw-frames) listened on the network, the expected encrypted data is:

**Expected encrypted tag U:** ```4E 05 A2 43```

"""

# Encryption: S0:= E(Key, A0)
cipher = AES.new(key, AES.MODE_ECB)
S0 = cipher.encrypt(A0)

# Perform S0[0:4] XOR T
U = bytes(a ^ b for (a, b) in zip(S0[0:4], T))
printhex (U)